{"version":3,"file":"app.b3dbca3e1d7c666cf63f.js","mappings":"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","sources":["webpack:///./src/Engine/Core/Core.js","webpack:///./src/Engine/Core/VertexBuffer.js","webpack:///./src/Engine/Core/GameLoop.js","webpack:///./src/Engine/Core/Input.js","webpack:///./src/Engine/Core/Resources/ResourceMap.js","webpack:///./src/Engine/Core/Resources/TextFileLoader.js","webpack:///./src/Engine/Core/Resources/Textures.js","webpack:///./src/Engine/Core/Resources/AudioClips.js","webpack:///./src/Engine/Shaders/SimpleShader.js","webpack:///./src/Engine/Shaders/TextureShader.js","webpack:///./src/Engine/Shaders/SpriteShader.js","webpack:///./src/Engine/Shaders/LineShader.js","webpack:///./src/Engine/Lib/gl-matrix/common.js","webpack:///./src/Engine/Lib/gl-matrix/mat4.js","webpack:///./src/Engine/Lib/gl-matrix/vec3.js","webpack:///./src/Engine/Lib/gl-matrix/vec4.js","webpack:///./src/Engine/Lib/gl-matrix/quat.js","webpack:///./src/Engine/Lib/gl-matrix/vec2.js","webpack:///./src/Engine/Lib/gl-matrix/mat3.js","webpack:///./src/Engine/Shaders/ShaderLightAtIndex.js","webpack:///./src/Engine/Shaders/LightShader.js","webpack:///./src/Engine/Core/Resources/DefaultResources.js","webpack:///./src/Engine/Core/Resources/Fonts.js","webpack:///./src/Engine/Scene.js","webpack:///./src/Engine/Utils/BoundingBox.js","webpack:///./src/Engine/Utils/ShakePosition.js","webpack:///./src/Engine/Cameras/CameraShake.js","webpack:///./src/Engine/Cameras/Camera_Manipulation.js","webpack:///./src/Engine/Utils/Interpolate.js","webpack:///./src/Engine/Utils/InterpolateVec2.js","webpack:///./src/Engine/Cameras/CameraState.js","webpack:///./src/Engine/Cameras/Camera_Input.js","webpack:///./src/Engine/Cameras/Camera_Xform.js","webpack:///./src/Engine/Cameras/Camera.js","webpack:///./src/Engine/Utils/Transform.js","webpack:///./src/Engine/Renderables/Renderable.js","webpack:///./src/Engine/Renderables/TextureRenderable.js","webpack:///./src/Engine/Renderables/SpriteRenderable.js","webpack:///./src/Engine/Renderables/FontRenderable.js","webpack:///./src/Engine/GameObjects/GameObject.js","webpack:///./src/Engine/Renderables/SpriteAnimateRenderable.js","webpack:///./src/Engine/Renderables/LightRenderable.js","webpack:///./src/MyGame/Objects/Hero.js","webpack:///./src/MyGame/Objects/Minion.js","webpack:///./src/Engine/Lights/Light.js","webpack:///./src/Engine/Lights/LightSet.js","webpack:///./src/MyGame/MyGame_Lights.js","webpack:///./src/MyGame/MyGame_LightControl.js","webpack:///./src/MyGame/main.js","webpack:///./src/Engine/Engine.js"],"sourcesContent":["class Core {\r\n    constructor(gEngine) {\r\n        this.mGL = null; // The graphical context to draw to\r\n        this.gEngine = gEngine;\r\n    }\r\n\r\n    getGL() { return this.mGL };\r\n\r\n    _initializeWebGL(htmlCanvasID, width = \"640\", height = \"480\") {\r\n        var canvas = document.getElementById(htmlCanvasID);\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        // Get the standard or experimental webgl and binds to the Canvas area\r\n        // store the results to the instance variable mGL\r\n        this.mGL = canvas.getContext(\"webgl\", { alpha: false }) || canvas.getContext(\"experimental-webgl\", { alpha: false });\r\n\r\n        // Allows transperency with textures.\r\n        this.mGL.blendFunc(this.mGL.SRC_ALPHA, this.mGL.ONE_MINUS_SRC_ALPHA);\r\n        this.mGL.enable(this.mGL.BLEND);\r\n\r\n        // Set images to flip y axis to match the texture coordinate space.\r\n        this.mGL.pixelStorei(this.mGL.UNPACK_FLIP_Y_WEBGL, true);\r\n        \r\n        if (this.mGL === null) {\r\n            document.write(\"<br><b>WebGL is not supported!</b>\");\r\n            return;\r\n        }\r\n\r\n        // // now initialize the VertexBuffer\r\n        // this.gEngine.VertexBuffer.initialize();\r\n    };\r\n\r\n    startScene(scene) {\r\n\r\n        scene.loadScene.call(scene); // Called in this way to keep correct context\r\n        this.gEngine.GameLoop.start(scene); // start the game loop after initialization is done\r\n        \r\n    };\r\n\r\n    initializeEngineCore(htmlCanvasID, myGame, width = \"640\", height = \"480\") {\r\n        this._initializeWebGL(htmlCanvasID, width, height);\r\n        this.gEngine.VertexBuffer.initialize();\r\n        this.gEngine.Input.initialize(htmlCanvasID);\r\n        this.gEngine.AudioClips.initAudioContext();\r\n        // Inits DefaultResources, when done, invoke the anonymous function to call startScene(myGame).\r\n        this.gEngine.DefaultResources.initialize(() => { this.startScene(myGame); });\r\n    };\r\n\r\n    clearCanvas(color) {\r\n        this.mGL.clearColor(color[0], color[1], color[2], color[3]);  // set the color to be cleared\r\n        this.mGL.clear(this.mGL.COLOR_BUFFER_BIT);      // clear to the color previously set\r\n    };\r\n\r\n    cleanUp () {\r\n        this.gEngine.DefaultResources.cleanUp();\r\n        this.gEngine.VertexBuffer.cleanUp();\r\n    };\r\n\r\n}\r\n\r\nexport { Core }","class VertexBuffer {\r\n    constructor(gEngine) {\r\n        // reference to the vertex positions for the square in the gl context\r\n        this.mSquareVertexBuffer = null;\r\n        // reference to the texture positions for the square vertices in the gl context\r\n        this.mTextureCoordBuffer = null;\r\n\r\n        this.gEngine = gEngine;\r\n\r\n        //  First: define the vertices for a square\r\n        this.verticesOfSquare = [\r\n            0.5, 0.5, 0.0,\r\n            -0.5, 0.5, 0.0,\r\n            0.5, -0.5, 0.0,\r\n            -0.5, -0.5, 0.0\r\n        ];\r\n        // Second: define the corresponding texture coordinates\r\n        this.textureCoordinates = [\r\n            1.0, 1.0,\r\n            0.0, 1.0,\r\n            1.0, 0.0,\r\n            0.0, 0.0\r\n        ];\r\n\r\n    }\r\n\r\n    initialize() {\r\n        this.gl = this.gEngine.Core.getGL();\r\n\r\n        // Step A: Create a buffer on the gGL context for our vertex positions\r\n        this.mSquareVertexBuffer = this.gl.createBuffer();\r\n\r\n        // Step B: Activate vertexBuffer\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.mSquareVertexBuffer);\r\n\r\n        // Step C: Loads verticesOfSquare into the vertexBuffer\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.verticesOfSquare), this.gl.STATIC_DRAW);\r\n\r\n        // Create a buffer on the gGL context for our vertex positions\r\n        this.mTextureCoordBuffer = this.gl.createBuffer();\r\n\r\n        // Activate vertexBuffer\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.mTextureCoordBuffer);\r\n\r\n        // Loads verticesOfSquare into the vertexBuffer\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.textureCoordinates), this.gl.STATIC_DRAW);\r\n\r\n    };\r\n\r\n    getGLVertexRef() { return this.mSquareVertexBuffer; };\r\n    getGLTexCoordRef() { return this.mTextureCoordBuffer; };\r\n\r\n    cleanUp() {\r\n        var gl = this.gEngine.Core.getGL();\r\n        gl.deleteBuffer(mSquareVertexBuffer);\r\n        gl.deleteBuffer(mTextureCoordBuffer);\r\n    };\r\n}\r\n\r\nexport { VertexBuffer }","class GameLoop {\r\n    constructor(gEngine) {\r\n        this.gEngine = gEngine;\r\n        this.kFPS = 60;          // Frames per second\r\n        this.kMPF = 1000 / this.kFPS; // Milliseconds per frame.\r\n\r\n        // this.iables for timing gameloop.\r\n        this.mPreviousTime = Date.now();\r\n        this.mLagTime;\r\n\r\n        // The current loop state (running or should stop)\r\n        this.mIsLoopRunning = false;\r\n        this.mMyGame = null;\r\n    };\r\n\r\n    _runLoop() {\r\n        if (this.mIsLoopRunning) {\r\n            // Step A: set up for next call to _runLoop and update input!\r\n            window.requestAnimationFrame(() => this._runLoop());\r\n\r\n            // Step B: compute how much time has elapsed since we last RunLoop was executed\r\n            let currentTime = Date.now();\r\n            let elapsedTime = currentTime - this.mPreviousTime;\r\n            this.mPreviousTime = currentTime;\r\n            this.mLagTime += elapsedTime;\r\n\r\n            // Step C: Make sure we update the game the appropriate number of times.\r\n            //      Update only every Milliseconds per frame.\r\n            //      If lag larger then update frames, update until caught up.\r\n            while ((this.mLagTime >= this.kMPF) && this.mIsLoopRunning) {\r\n                this.gEngine.Input.update();\r\n                this.mMyGame.update();      // call MyGame.update()\r\n                this.mLagTime -= this.kMPF;\r\n            }\r\n\r\n            // Step D: now let's draw\r\n\r\n            this.mMyGame.draw();\r\n\r\n\r\n        } else {\r\n            // this scene is done, unload it!\r\n            this.mMyGame.unloadScene();\r\n        }\r\n    };\r\n\r\n    // update and draw functions must be set before this.\r\n    _startLoop() {\r\n        // Step A: reset frame time \r\n        this.mPreviousTime = Date.now();\r\n        this.mLagTime = 0.0;\r\n\r\n        // Step B: remember that loop is now running\r\n        this.mIsLoopRunning = true;\r\n\r\n        // Step C: request _runLoop to start when loading is done\r\n        requestAnimationFrame(() => { this._runLoop(); });\r\n    };\r\n    // update and draw functions must be set before this.\r\n    start(myGame) {\r\n        this.mMyGame = myGame;\r\n        \r\n        this.gEngine.ResourceMap.setLoadCompleteCallback(\r\n            () => {\r\n                this.mMyGame.initialize();\r\n                this._startLoop();\r\n            }\r\n        );\r\n    };\r\n\r\n    //\r\n    stop() {\r\n        this.mIsLoopRunning = false;\r\n    };\r\n\r\n}\r\nexport { GameLoop }","const kKeys = {\r\n    // arrows\r\n    Left: 37,\r\n    Up: 38,\r\n    Right: 39,\r\n    Down: 40,\r\n\r\n    // space bar\r\n    Space: 32,\r\n\r\n    // numbers \r\n    Zero: 48,\r\n    One: 49,\r\n    Two: 50,\r\n    Three: 51,\r\n    Four: 52,\r\n    Five: 53,\r\n    Six: 54,\r\n    Seven: 55,\r\n    Eight: 56,\r\n    Nine: 57,\r\n\r\n    // Alphabets\r\n    A: 65,\r\n    B: 66,\r\n    C: 67,\r\n    D: 68,\r\n    E: 69,\r\n    F: 70,\r\n    G: 71,\r\n    H: 72,\r\n    I: 73,\r\n    J: 74,\r\n    K: 75,\r\n    L: 76,\r\n    M: 77,\r\n    N: 78,\r\n    O: 79,\r\n    P: 80,\r\n    Q: 81,\r\n    R: 82,\r\n    S: 83,\r\n    T: 84,\r\n    U: 85,\r\n    V: 86,\r\n    W: 87,\r\n    X: 88,\r\n    Y: 89,\r\n    Z: 90,\r\n\r\n    LastKeyCode: 222\r\n};\r\n\r\nconst kMouseButton = {\r\n    Left: 0,\r\n    Middle: 1,\r\n    Right: 2\r\n};\r\n\r\nclass Input {\r\n    constructor() {\r\n\r\n        // Previous key state\r\n        this.mKeyPreviousState = [];     // a new array\r\n        // The pressed keys.\r\n        this.mIsKeyPressed = [];\r\n        // Click events: once an event is set, it will remain there until polled\r\n        this.mIsKeyClicked = [];\r\n        this.keys = kKeys;\r\n        this.mouseButton = kMouseButton;\r\n\r\n        // Support mouse\r\n        this.mCanvas = null;\r\n        this.mButtonPreviousState = [];\r\n        this.mIsButtonPressed = [];\r\n        this.mIsButtonClicked = [];\r\n        this.mMousePosX = -1;\r\n        this.mMousePosY = -1;\r\n    };\r\n\r\n    // Event handler functions\r\n    _onKeyDown(event) {\r\n        this.mIsKeyPressed[event.keyCode] = true;\r\n    };\r\n    _onKeyUp(event) {\r\n        this.mIsKeyPressed[event.keyCode] = false;\r\n    };\r\n\r\n    _onMouseMove(event) {\r\n        let inside = false;\r\n        let bBox = this.mCanvas.getBoundingClientRect();\r\n        // In Canvas Space now. Convert via ratio from canvas to client.\r\n        let x = Math.round((event.clientX - bBox.left) * (this.mCanvas.width / bBox.width));\r\n        let y = Math.round((event.clientY - bBox.top) * (this.mCanvas.height / bBox.height));\r\n\r\n        if ((x >= 0) && (x < this.mCanvas.width) &&\r\n            (y >= 0) && (y < this.mCanvas.height)) {\r\n            this.mMousePosX = x;\r\n            this.mMousePosY = this.mCanvas.height - 1 - y;\r\n            inside = true;\r\n        }\r\n        return inside;\r\n    };\r\n\r\n    _onMouseDown(event) {\r\n        if (this._onMouseMove(event)) {\r\n            this.mIsButtonPressed[event.button] = true;\r\n        }\r\n    };\r\n\r\n    _onMouseUp(event) {\r\n        this._onMouseMove(event);\r\n        this.mIsButtonPressed[event.button] = false;\r\n    };\r\n\r\n    initialize(canvasID) {\r\n        let i;\r\n        for (i = 0; i < kKeys.LastKeyCode; i++) {\r\n            this.mIsKeyPressed[i] = false;\r\n            this.mKeyPreviousState[i] = false;\r\n            this.mIsKeyClicked[i] = false;\r\n        }\r\n        // register handlers \r\n        window.addEventListener('keyup', (event) => this._onKeyUp(event));\r\n        window.addEventListener('keydown', (event) => this._onKeyDown(event));\r\n\r\n        for (i = 0; i < 3; i++) {\r\n            this.mButtonPreviousState[i] = false;\r\n            this.mIsButtonPressed[i] = false;\r\n            this.mIsButtonClicked[i] = false;\r\n        }\r\n\r\n        window.addEventListener('mousedown', (event) => this._onMouseDown(event));\r\n        window.addEventListener('mouseup', (event) => this._onMouseUp(event));\r\n        window.addEventListener('mousemove', (event) => this._onMouseMove(event));\r\n        this.mCanvas = document.getElementById(canvasID);\r\n    };\r\n\r\n    update() {\r\n        let i;\r\n        for (i = 0; i < kKeys.LastKeyCode; i++) {\r\n            this.mIsKeyClicked[i] = (!this.mKeyPreviousState[i]) && this.mIsKeyPressed[i];\r\n            this.mKeyPreviousState[i] = this.mIsKeyPressed[i];\r\n        }\r\n\r\n        for (i = 0; i < 3; i++) {\r\n            this.mIsButtonClicked[i] = (!this.mButtonPreviousState[i]) && this.mIsButtonPressed[i];\r\n            this.mButtonPreviousState[i] = this.mIsButtonPressed[i];\r\n        }\r\n    };\r\n\r\n    // Function for GameEngine programmer to test if a key is pressed down\r\n    isKeyPressed(keyCode) {\r\n\r\n        return this.mIsKeyPressed[keyCode];\r\n    };\r\n\r\n    isKeyClicked(keyCode) {\r\n        return (this.mIsKeyClicked[keyCode]);\r\n    };\r\n\r\n    isButtonPressed(button) {\r\n        return this.mIsButtonPressed[button];\r\n    };\r\n\r\n    isButtonClicked(button) {\r\n        return this.mIsButtonClicked[button];\r\n    };\r\n\r\n    getMousePosX() { return this.mMousePosX; };\r\n    getMousePosY() { return this.mMousePosY; };\r\n\r\n    \r\n}\r\n\r\nexport { Input }","class MapEntry {\r\n    constructor(rName) {\r\n        this.mAsset = rName;\r\n        this.mRefCount = 1;\r\n    }\r\n};\r\n\r\nclass ResourceMap {\r\n    constructor() {\r\n        // Number of outstanding load operations\r\n        this.mNumOutstandingLoads = 0;\r\n\r\n        // Callback function when all textures are loaded\r\n        this.mLoadCompleteCallback = null;\r\n\r\n        // Resource storage\r\n        this.mResourceMap = {};\r\n    }\r\n\r\n    isAssetLoaded(rName) {\r\n        return (rName in this.mResourceMap);\r\n    };\r\n    /*\r\n    * Register one more resource to load\r\n    */\r\n    asyncLoadRequested(rName) {\r\n        this.mResourceMap[rName] = new MapEntry(rName); // place holder for the resource to be loaded\r\n        ++this.mNumOutstandingLoads;\r\n    };\r\n\r\n    asyncLoadCompleted(rName, loadedAsset) {\r\n        console.log(\"ResourceMap :: asyncLoadCompleted************: \" + this.mNumOutstandingLoads);\r\n        if (!this.isAssetLoaded(rName)) {\r\n            console.log(\"ResourceMap:: gEngine.asyncLoadCompleted: [\" + rName + \"] not in map!\");\r\n        }\r\n        this.mResourceMap[rName].mAsset = loadedAsset;\r\n        --this.mNumOutstandingLoads;\r\n        this._checkForAllLoadCompleted();\r\n    };\r\n\r\n    _checkForAllLoadCompleted() {\r\n        if ((this.mNumOutstandingLoads === 0) && (this.mLoadCompleteCallback !== null)) {\r\n            // ensures the load complete call back will only be called once!\r\n            var funToCall = this.mLoadCompleteCallback;\r\n            this.mLoadCompleteCallback = null;\r\n            funToCall();\r\n\r\n        }\r\n        console.log(\"ResourceMap::_checkForAllLoadCompleted\")\r\n    };\r\n\r\n    // Make sure to set the callback _AFTER_ all load commands are issued\r\n    setLoadCompleteCallback(funct) {\r\n        this.mLoadCompleteCallback = funct;\r\n        // in case all loading are done\r\n        console.log(\"ResourceMap::setLoadCompleteCallback::\" )\r\n        this._checkForAllLoadCompleted();\r\n    };\r\n\r\n    retrieveAsset(rName) {\r\n        var r = null;\r\n        if (rName in this.mResourceMap) {\r\n            r = this.mResourceMap[rName].mAsset;\r\n        } else {\r\n            console.log(\"ResourceMap:: gEngine.retrieveAsset: [\" + rName + \"] not in map!\");\r\n        }\r\n        return r;\r\n    };\r\n\r\n    incAssetRefCount(rName) {\r\n        this.mResourceMap[rName].mRefCount += 1;\r\n    };\r\n\r\n    unloadAsset(rName) {\r\n        let c;\r\n        if (rName in this.mResourceMap) {\r\n            this.mResourceMap[rName].mRefCount -= 1;\r\n            c = this.mResourceMap[rName].mRefCount;\r\n            if (c === 0) {\r\n                delete this.mResourceMap[rName];\r\n            }\r\n        }\r\n        console.log(\"ResourceMap::unloadAsset: \"+c);\r\n        return c;\r\n    };\r\n}\r\n\r\nexport { ResourceMap }","\r\nconst eTextFileType = {\r\n    eXMLFile: 0,\r\n    eTextFile: 1\r\n};\r\n\r\nclass TextFileLoader {\r\n    constructor(gEngine) {\r\n        this.gEngine = gEngine;\r\n        this.eTextFileType = eTextFileType;\r\n    }\r\n\r\n    loadTextFile(fileName, fileType, callbackFunction) {\r\n        if (!(this.gEngine.ResourceMap.isAssetLoaded(fileName))) {\r\n            // Update resources in load counter.\r\n            this.gEngine.ResourceMap.asyncLoadRequested(fileName);\r\n\r\n            // Asynchronously request the data from server.\r\n            let req = new XMLHttpRequest();\r\n            req.onreadystatechange = () => {\r\n                if ((req.readyState === 4) && (req.status !== 200)) {\r\n                    alert(fileName + \": loading failed! [Hint: you cannot double click index.html to run this project. \" +\r\n                        \"The index.html file must be loaded by a web-server.]\");\r\n                }\r\n            };\r\n            req.open('GET', fileName, true);\r\n            req.setRequestHeader('Content-Type', 'text/xml');\r\n\r\n            req.onload = ()=> {\r\n                let fileContent = null;\r\n                if (fileType === eTextFileType.eXMLFile) {\r\n                    let parser = new DOMParser();\r\n                    fileContent = parser.parseFromString(req.responseText, \"text/xml\");\r\n                } else {\r\n                    fileContent = req.responseText;\r\n                }\r\n                // 这个需要使用箭头函数，不然this会丢失                 \r\n                this.gEngine.ResourceMap.asyncLoadCompleted(fileName, fileContent);\r\n                if ((callbackFunction !== null) && (callbackFunction !== undefined)) {\r\n                    callbackFunction(fileName);\r\n                }\r\n            };\r\n            req.send();\r\n        } else {\r\n            this.gEngine.ResourceMap.incAssetRefCount(fileName);\r\n            if ((callbackFunction !== null) && (callbackFunction !== undefined)) {\r\n                callbackFunction(fileName);\r\n            }\r\n        }\r\n    };\r\n\r\n    unloadTextFile(fileName) {\r\n        this.gEngine.ResourceMap.unloadAsset(fileName);\r\n    };\r\n}\r\n\r\nexport { TextFileLoader }","class TextureInfo {\r\n    constructor(name, w, h, id) {\r\n        this.mName = name;\r\n        this.mWidth = w;\r\n        this.mHeight = h;\r\n        this.mGLTexID = id;\r\n        this.mColorArray = null;\r\n    }\r\n}\r\nclass Textures {\r\n    constructor(gEngine) {\r\n        this.gEngine = gEngine;\r\n        this.gl = gEngine.Core.getGL();\r\n    }\r\n\r\n    _processLoadedImage(textureName, image) {\r\n        \r\n        this.gl = this.gEngine.Core.getGL();\r\n        // Generate a texture reference to the webGL context\r\n        let textureID = this.gl.createTexture();\r\n\r\n        // bind the texture reference with the current texture functionality in the webGL\r\n        this.gl.bindTexture(this.gl.TEXTURE_2D, textureID);\r\n\r\n        // Load the texture into the texture data structure with descriptive info.\r\n        // Parameters:\r\n        //  1: Which \"binding point\" or target the texture is being loaded to.\r\n        //  2: Level of detail. Used for mipmapping. 0 is base texture level.\r\n        //  3: Internal format. The composition of each element. i.e. pixels.\r\n        //  4: Format of texel data. Must match internal format.\r\n        //  5: The data type of the texel data.\r\n        //  6: Texture Data.\r\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\r\n\r\n        // Creates a mipmap for this texture.\r\n        this.gl.generateMipmap(this.gl.TEXTURE_2D);\r\n\r\n        // Tells WebGL that we are done manipulating data at the mGL.TEXTURE_2D target.\r\n        this.gl.bindTexture(this.gl.TEXTURE_2D, null);\r\n\r\n        let texInfo = new TextureInfo(textureName, image.naturalWidth, image.naturalHeight, textureID);\r\n        this.gEngine.ResourceMap.asyncLoadCompleted(textureName, texInfo);\r\n    };\r\n\r\n    // Loads an texture so that it can be drawn.\r\n    // If already in the map, will do nothing.\r\n    loadTexture(textureName) {\r\n        if (!(this.gEngine.ResourceMap.isAssetLoaded(textureName))) {\r\n            // Create new Texture object.\r\n            let img = new Image();\r\n\r\n            // Update resources in loading counter.\r\n            this.gEngine.ResourceMap.asyncLoadRequested(textureName);\r\n\r\n            // When the texture loads, convert it to the WebGL format then put\r\n            // it back into the mTextureMap.\r\n            \r\n            img.onload = () => {\r\n                this._processLoadedImage(textureName, img);\r\n            };\r\n            img.src = textureName;\r\n        } else {\r\n            this.gEngine.ResourceMap.incAssetRefCount(textureName);\r\n        }\r\n    };\r\n    // Remove the reference to allow associated memory \r\n    // be available for subsequent garbage collection\r\n    unloadTexture(textureName) {\r\n        \r\n        let texInfo = this.gEngine.ResourceMap.retrieveAsset(textureName);\r\n        this.gl.deleteTexture(texInfo.mGLTexID);\r\n        this.gEngine.ResourceMap.unloadAsset(textureName);\r\n    };\r\n\r\n    activateTexture(textureName) {\r\n        this.gl = this.gEngine.Core.getGL();\r\n        let texInfo = this.gEngine.ResourceMap.retrieveAsset(textureName);\r\n        //console.log(\"Textures::activateTexture() \");\r\n        if (!this.gl) return;\r\n        // Binds our texture reference to the current webGL texture functionality\r\n        this.gl.bindTexture(this.gl.TEXTURE_2D, texInfo.mGLTexID);\r\n\r\n        // To prevent texture wrappings\r\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\r\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\r\n\r\n        // Handles how magnification and minimization filters will work.\r\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\r\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR);\r\n\r\n        // For pixel-graphics where you want the texture to look \"sharp\" do the following:\r\n        // this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);\r\n        // this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);\r\n    };\r\n\r\n    deactivateTexture() {\r\n        this.gl.bindTexture(this.gl.TEXTURE_2D, null);\r\n    };\r\n\r\n    getTextureInfo(textureName) {\r\n        return this.gEngine.ResourceMap.retrieveAsset(textureName);\r\n    };\r\n\r\n    getColorArray (textureName) {\r\n        let texInfo = this.getTextureInfo(textureName);\r\n        if (texInfo.mColorArray === null) {\r\n            // create a framebuffer bind it to the texture, and read the color content\r\n            // Hint from: http://stackoverflow.com/questions/13626606/read-pixels-from-a-webgl-texture \r\n            let gl = this.gEngine.Core.getGL();\r\n            let fb = gl.createFramebuffer();\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texInfo.mGLTexID, 0);\r\n            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {\r\n                let pixels = new Uint8Array(texInfo.mWidth * texInfo.mHeight * 4);\r\n                gl.readPixels(0, 0, texInfo.mWidth, texInfo.mHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\r\n                texInfo.mColorArray = pixels;\r\n            } else {\r\n                alert(\"WARNING: Engine.Textures.getColorArray() failed!\");\r\n            }\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n            gl.deleteFramebuffer(fb);\r\n        }\r\n        return texInfo.mColorArray;\r\n    };\r\n}\r\n\r\nexport { Textures };","class AudioClips {\r\n    constructor(gEngine) {\r\n        this.gEngine = gEngine;\r\n        this.mAudioContext = null;\r\n        this.mBgAudioNode = null;\r\n    };\r\n\r\n    initAudioContext() {\r\n        try {\r\n            let AudioContext = window.AudioContext || window.webkitAudioContext;\r\n            this.mAudioContext = new AudioContext();\r\n        } catch (e) { alert(\"Web Audio Is not supported.\"); }\r\n    };\r\n\r\n    loadAudio(clipName) {\r\n        if (!(this.gEngine.ResourceMap.isAssetLoaded(clipName))) {\r\n            // Update resources in load counter.\r\n            this.gEngine.ResourceMap.asyncLoadRequested(clipName);\r\n\r\n            // Asynchronously request the data from server.\r\n            var req = new XMLHttpRequest();\r\n            req.onreadystatechange = () => {\r\n                if ((req.readyState === 4) && (req.status !== 200)) {\r\n                    alert(clipName + \": loading failed! [Hint: you cannot double click index.html to run this project. \" +\r\n                        \"The index.html file must be loaded by a web-server.]\");\r\n                }\r\n            };\r\n            req.open('GET', clipName, true);\r\n            // Specify that the request retrieves binary data.\r\n            req.responseType = 'arraybuffer';\r\n\r\n            req.onload = () => {\r\n                // Asynchronously decode, then call the function in parameter.\r\n\r\n                this.mAudioContext.decodeAudioData(req.response,\r\n                    (buffer) => {\r\n                        this.gEngine.ResourceMap.asyncLoadCompleted(clipName, buffer);\r\n                    }\r\n                );\r\n            };\r\n            req.send();\r\n        } else {\r\n            this.gEngine.ResourceMap.incAssetRefCount(clipName);\r\n        }\r\n    };\r\n\r\n    unloadAudio(clipName) {\r\n        this.gEngine.ResourceMap.unloadAsset(clipName);\r\n    };\r\n\r\n    playACue(clipName) {\r\n        let clipInfo = this.gEngine.ResourceMap.retrieveAsset(clipName);\r\n        if (clipInfo !== null) {\r\n            // SourceNodes are one use only.\r\n            var sourceNode = this.mAudioContext.createBufferSource();\r\n            sourceNode.buffer = clipInfo;\r\n            sourceNode.connect(this.mAudioContext.destination);\r\n            sourceNode.start(0);\r\n        }\r\n    };\r\n\r\n    playBackgroundAudio(clipName) {\r\n\r\n        var clipInfo = this.gEngine.ResourceMap.retrieveAsset(clipName);\r\n        console.log(\"clipInfo\");\r\n        //console.log(clipInfo)\r\n        if (clipInfo !== null && typeof (clipInfo) !== \"string\") {\r\n            //console.log(\"AudioClips::playBackgroundAudio::clipInfo: \" + typeof (clipInfo));\r\n            // Stop audio if playing.\r\n            this.stopBackgroundAudio();\r\n\r\n            this.mBgAudioNode = this.mAudioContext.createBufferSource();\r\n            // console.log(\"AudioClips::playBackgroundAudio: \" + typeof (this.mBgAudioNode));\r\n            this.mBgAudioNode.buffer = clipInfo;\r\n            this.mBgAudioNode.connect(this.mAudioContext.destination);\r\n            this.mBgAudioNode.loop = true;\r\n            this.mBgAudioNode.start(0);\r\n        }\r\n    };\r\n\r\n    stopBackgroundAudio() {\r\n        // Check if the audio is  playing.\r\n        if (this.mBgAudioNode !== null) {\r\n            this.mBgAudioNode.stop(0);\r\n            this.mBgAudioNode = null;\r\n        }\r\n    };\r\n\r\n    isBackgroundAudioPlaying() {\r\n        return (this.mBgAudioNode !== null);\r\n    };\r\n\r\n};\r\nexport { AudioClips }","class SimpleShader {\r\n    constructor(gEngine, vertexShaderFilePath, fragmentShaderFilePath) {\r\n        // instance variables\r\n        // Convention: all instance variables: mVariables\r\n        this.gEngine = gEngine;\r\n        this.gl = gEngine.Core.getGL();\r\n\r\n        this.mCompiledShader = null;  // reference to the compiled shader in webgl context  \r\n        this.mShaderVertexPositionAttribute = null; // reference to SquareVertexPosition within the shader\r\n\r\n        this.mPixelColor = null; //reference to the pixelColor uniform in the fragment shader\r\n        this.mModelTransform = null;\r\n        this.mViewProjTransform = null;\r\n        this.mGlobalAmbientColor = null;\r\n        this.mGlobalAmbientIntensity = null;\r\n        // start of constructor code\r\n        // \r\n        // Step A: load and compile vertex and fragment shaders\r\n        this.vertexShader = this._compileShader(vertexShaderFilePath, this.gl.VERTEX_SHADER);\r\n        this.fragmentShader = this._compileShader(fragmentShaderFilePath, this.gl.FRAGMENT_SHADER);\r\n\r\n        // Step B: Create and link the shaders into a program.\r\n        this.mCompiledShader = this.gl.createProgram();\r\n        this.gl.attachShader(this.mCompiledShader, this.vertexShader);\r\n        this.gl.attachShader(this.mCompiledShader, this.fragmentShader);\r\n        this.gl.linkProgram(this.mCompiledShader);\r\n\r\n        // Step C: check for error\r\n        if (!this.gl.getProgramParameter(this.mCompiledShader, this.gl.LINK_STATUS)) {\r\n            alert(\"Error linking shader\");\r\n            return null;\r\n        }\r\n\r\n        // Step D: Gets a reference to the aSquareVertexPosition attribute within the shaders.\r\n        this.mShaderVertexPositionAttribute = this.gl.getAttribLocation(\r\n            this.mCompiledShader, \"aSquareVertexPosition\");\r\n\r\n        // Step E: Activates the vertex buffer loaded in EngineCore_VertexBuffer.js\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, gEngine.VertexBuffer.getGLVertexRef());\r\n\r\n        // Step F: Describe the characteristic of the vertex position attribute\r\n        this.gl.vertexAttribPointer(this.mShaderVertexPositionAttribute,\r\n            3,              // each element is a 3-float (x,y.z)\r\n            this.gl.FLOAT,       // data type is FLOAT\r\n            false,          // if the content is normalized vectors\r\n            0,              // number of bytes to skip in between elements\r\n            0);\r\n\r\n        // Step G: Gets a reference to the uniform variable uPixelColor in the\r\n        // fragment shader\r\n        this.mPixelColor = this.gl.getUniformLocation(this.mCompiledShader, \"uPixelColor\");\r\n        this.mModelTransform = this.gl.getUniformLocation(this.mCompiledShader, \"uModelTransform\");\r\n        this.mViewProjTransform = this.gl.getUniformLocation(this.mCompiledShader, \"uViewProjTransform\");\r\n        this.mGlobalAmbientColor = this.gl.getUniformLocation(this.mCompiledShader, \"uGlobalAmbientColor\");\r\n        this.mGlobalAmbientIntensity = this.gl.getUniformLocation(this.mCompiledShader, \"uGlobalAmbientIntensity\");\r\n    }\r\n\r\n    getShader() { return this.mCompiledShader; };\r\n\r\n    activateShader(pixelColor, aCamera) {\r\n        this.gl.useProgram(this.mCompiledShader);\r\n        this.gl.uniformMatrix4fv(this.mViewProjTransform, false, aCamera.getVPMatrix());\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.gEngine.VertexBuffer.getGLVertexRef());\r\n        this.gl.vertexAttribPointer(this.mShaderVertexPositionAttribute,\r\n            3,              // each element is a 3-float (x,y.z)\r\n            this.gl.FLOAT,       // data type is FLOAT\r\n            false,          // if the content is normalized vectors\r\n            0,              // number of bytes to skip in between elements\r\n            0);             // offsets to the first element\r\n        this.gl.enableVertexAttribArray(this.mShaderVertexPositionAttribute);\r\n        this.gl.uniform4fv(this.mPixelColor, pixelColor);\r\n        this.gl.uniform4fv(this.mGlobalAmbientColor, this.gEngine.DefaultResources.getGlobalAmbientColor());\r\n        this.gl.uniform1f(this.mGlobalAmbientIntensity, this.gEngine.DefaultResources.getGlobalAmbientIntensity());\r\n    };\r\n\r\n\r\n    // Loads per-object model transform to the vertex shader\r\n    loadObjectTransform(modelTransform) {\r\n        this.gl.uniformMatrix4fv(this.mModelTransform, false, modelTransform);\r\n    };\r\n\r\n    _loadAndCompileShader(file, shaderType) {\r\n        var shaderSource, compiledShader;\r\n\r\n\r\n        // Step A: Get the shader source from index.html\r\n        //shaderText = document.getElementById(id);\r\n        shaderSource = file;\r\n        // console.log(shaderSource);\r\n\r\n        // Step B: Create the shader based on the shader type: vertex or fragment\r\n        compiledShader = this.gl.createShader(shaderType);\r\n\r\n        // Step C: Compile the created shader\r\n        this.gl.shaderSource(compiledShader, shaderSource);\r\n        this.gl.compileShader(compiledShader);\r\n\r\n        // Step D: check for errors and return results (null if error)\r\n        // The log info is how shader compilation errors are typically displayed.\r\n        // This is useful for debugging the shaders.\r\n        if (!this.gl.getShaderParameter(compiledShader, this.gl.COMPILE_STATUS)) {\r\n            alert(\"A shader compiling error occurred: \" + this.gl.getShaderInfoLog(compiledShader));\r\n        }\r\n\r\n        return compiledShader;\r\n    };\r\n\r\n    _compileShader(filePath, shaderType) {\r\n        var gl = this.gEngine.Core.getGL();\r\n        var shaderSource = null, compiledShader = null;\r\n\r\n        // Step A: Access the shader textfile\r\n        shaderSource = this.gEngine.ResourceMap.retrieveAsset(filePath);\r\n\r\n        if (shaderSource === null) {\r\n            alert(\"WARNING: Loading of:\" + filePath + \" Failed!\");\r\n            return null;\r\n        }\r\n\r\n        // Step B: Create the shader based on the shader type: vertex or fragment\r\n        compiledShader = this.gl.createShader(shaderType);\r\n\r\n        // Step C: Compile the created shader\r\n        this.gl.shaderSource(compiledShader, shaderSource);\r\n        this.gl.compileShader(compiledShader);\r\n\r\n        // Step D: check for errors and return results (null if error)\r\n        // The log info is how shader compilation errors are typically displayed.\r\n        // This is useful for debugging the shaders.\r\n        if (!this.gl.getShaderParameter(compiledShader, this.gl.COMPILE_STATUS)) {\r\n            alert(\"A shader compiling error occurred: \" + this.gl.getShaderInfoLog(compiledShader));\r\n        }\r\n\r\n        return compiledShader;\r\n    };\r\n\r\n    cleanUp() {\r\n        var gl = this.gEngine.Core.getGL();\r\n        gl.detachShader(this.mCompiledShader, this.mVertexShader);\r\n        gl.detachShader(this.mCompiledShader, this.mFragmentShader);\r\n        gl.deleteShader(this.mVertexShader);\r\n        gl.deleteShader(this.mFragmentShader);\r\n    };\r\n}\r\n\r\nexport { SimpleShader }","import { SimpleShader } from \"./SimpleShader\";\r\n\r\nclass TextureShader extends SimpleShader {\r\n    constructor(gEnigne, vertexShaderPath, fragmentShaderPath) {\r\n        super(gEnigne, vertexShaderPath, fragmentShaderPath);\r\n        // reference to aTextureCoordinate within the shader\r\n        this.mShaderTextureCoordAttribute = null;\r\n\r\n        // get the reference of aTextureCoordinate within the shader\r\n        this.gl = this.gEngine.Core.getGL();\r\n        console.log(\"TextureShader::constructor \");\r\n        this.mShaderTextureCoordAttribute = this.gl.getAttribLocation(this.mCompiledShader, \"aTextureCoordinate\");\r\n    }\r\n\r\n    // Overriding the Activation of the shader for rendering\r\n\r\n    activateShader(pixelColor, aCamera) {\r\n        // first call the super class's activate\r\n        super.activateShader( pixelColor, aCamera);\r\n    \r\n        // now our own functionality: enable texture coordinate array\r\n        this.gl = this.gEngine.Core.getGL();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.gEngine.VertexBuffer.getGLTexCoordRef());\r\n        this.gl.enableVertexAttribArray(this.mShaderTextureCoordAttribute);\r\n        this.gl.vertexAttribPointer(this.mShaderTextureCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);\r\n    };\r\n}\r\n\r\nexport { TextureShader }","import { TextureShader } from \"./TextureShader\";\r\nimport { SimpleShader } from \"./SimpleShader\";\r\n\r\nclass SpriteShader extends TextureShader {\r\n    constructor(gEnigne, vertexShaderPath, fragmentShaderPath) {\r\n        super(gEnigne, vertexShaderPath, fragmentShaderPath);\r\n        this.mTexCoordBuffer = null; // this is the reference to gl buffer that contains the actual texture coordinate\r\n        this.gEngine = gEnigne;\r\n        this.initTexCoord = [\r\n            1.0, 1.0,\r\n            0.0, 1.0,\r\n            1.0, 0.0,\r\n            0.0, 0.0\r\n        ];\r\n\r\n        this.gl = this.gEngine.Core.getGL();\r\n\r\n        this.mTexCoordBuffer = this.gl.createBuffer();\r\n\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.mTexCoordBuffer);\r\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.initTexCoord), this.gl.DYNAMIC_DRAW);\r\n        //// DYNAMIC_DRAW: says buffer content may change!\r\n    }\r\n\r\n    // Overriding the Activation of the shader for rendering\r\n\r\n    activateShader(pixelColor, aCamera) {\r\n        // first call the super class's activate\r\n        // super.activateShader(pixelColor, aCamera);\r\n        SimpleShader.prototype.activateShader.call(this, pixelColor, aCamera);\r\n        // now binds the proper texture coordinate buffer\r\n        this.gl = this.gEngine.Core.getGL();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.mTexCoordBuffer);\r\n        this.gl.vertexAttribPointer(this.mShaderTextureCoordAttribute,\r\n            2,\r\n            this.gl.FLOAT,\r\n            false,\r\n            0,\r\n            0);\r\n        this.gl.enableVertexAttribArray(this.mShaderTextureCoordAttribute);\r\n    };\r\n\r\n    setTextureCoordinate(texCoord) {\r\n        this.gl = this.gEngine.Core.getGL();\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.mTexCoordBuffer);\r\n        this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, new Float32Array(texCoord));\r\n    };\r\n\r\n    cleanUp () {\r\n        var gl = this.gEngine.Core.getGL();\r\n        gl.deleteBuffer(this.mTexCoordBuffer);\r\n        // now call super class's clean up ...\r\n        SimpleShader.prototype.cleanUp.call(this);\r\n    };\r\n}\r\n\r\nexport { SpriteShader }","import { SimpleShader } from \"./SimpleShader\";\r\n\r\nclass LineShader extends SimpleShader {\r\n\r\n    constructor(gEngine, vertexShaderFilePath, fragmentShaderFilePath) {\r\n        super(gEngine, vertexShaderFilePath, fragmentShaderFilePath);\r\n        this.mPointSizeRef = null;            // reference to the PointSize uniform\r\n        this.gl = gEngine.Core.getGL();\r\n        this.gEngine = gEngine;\r\n        // point size uniform\r\n        this.mPointSizeRef = this.gl.getUniformLocation(this.mCompiledShader, \"uPointSize\");\r\n\r\n        this.mPointSize = 1;\r\n    };\r\n\r\n    activateShader(pixelColor, aCamera) {\r\n        // first call the super class's activate\r\n        super.activateShader(pixelColor, aCamera);\r\n\r\n        // now our own functionality: enable texture coordinate array\r\n        var gl = this.gl;\r\n        gl.uniform1f(this.mPointSizeRef, this.mPointSize);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, gEngine.VertexBuffer.getGLLineVertexRef());\r\n        gl.vertexAttribPointer(this.mShaderVertexPositionAttribute,\r\n            3,              // each element is a 3-float (x,y.z)\r\n            gl.FLOAT,       // data type is FLOAT\r\n            false,          // if the content is normalized vectors\r\n            0,              // number of bytes to skip in between elements\r\n            0);\r\n\r\n        gl.enableVertexAttribArray(this.mShaderVertexPositionAttribute);\r\n    };\r\n\r\n    setPointSize(w) { this.mPointSize = w; };\r\n};\r\n\r\nexport { LineShader }","/**\n * Common utilities\n * @module glMatrix\n */\n\n// Configuration Constants\nexport const EPSILON = 0.000001;\nexport let ARRAY_TYPE =\n  typeof Float32Array !== \"undefined\" ? Float32Array : Array;\nexport let RANDOM = Math.random;\nexport let ANGLE_ORDER = \"zyx\";\n\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\n\nconst degree = Math.PI / 180;\n\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\nexport function toRadian(a) {\n  return a * degree;\n}\n\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\n\nif (!Math.hypot)\n  Math.hypot = function () {\n    var y = 0,\n      i = arguments.length;\n    while (i--) y += arguments[i] * arguments[i];\n    return Math.sqrt(y);\n  };\n","import * as glMatrix from \"./common.js\";\n\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\nexport function create() {\n  let out = new glMatrix.ARRAY_TYPE(16);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\nexport function clone(a) {\n  let out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\nexport function fromValues(\n  m00,\n  m01,\n  m02,\n  m03,\n  m10,\n  m11,\n  m12,\n  m13,\n  m20,\n  m21,\n  m22,\n  m23,\n  m30,\n  m31,\n  m32,\n  m33\n) {\n  let out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\nexport function set(\n  out,\n  m00,\n  m01,\n  m02,\n  m03,\n  m10,\n  m11,\n  m12,\n  m13,\n  m20,\n  m21,\n  m22,\n  m23,\n  m30,\n  m31,\n  m32,\n  m33\n) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    let a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n    let a12 = a[6],\n      a13 = a[7];\n    let a23 = a[11];\n\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\nexport function invert(out, a) {\n  let a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  let a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  let a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  let a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  // Calculate the determinant\n  let det =\n    b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n  return out;\n}\n\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\nexport function adjoint(out, a) {\n  let a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  let a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  let a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  let a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  out[0] = a11 * b11 - a12 * b10 + a13 * b09;\n  out[1] = a02 * b10 - a01 * b11 - a03 * b09;\n  out[2] = a31 * b05 - a32 * b04 + a33 * b03;\n  out[3] = a22 * b04 - a21 * b05 - a23 * b03;\n  out[4] = a12 * b08 - a10 * b11 - a13 * b07;\n  out[5] = a00 * b11 - a02 * b08 + a03 * b07;\n  out[6] = a32 * b02 - a30 * b05 - a33 * b01;\n  out[7] = a20 * b05 - a22 * b02 + a23 * b01;\n  out[8] = a10 * b10 - a11 * b08 + a13 * b06;\n  out[9] = a01 * b08 - a00 * b10 - a03 * b06;\n  out[10] = a30 * b04 - a31 * b02 + a33 * b00;\n  out[11] = a21 * b02 - a20 * b04 - a23 * b00;\n  out[12] = a11 * b07 - a10 * b09 - a12 * b06;\n  out[13] = a00 * b09 - a01 * b07 + a02 * b06;\n  out[14] = a31 * b01 - a30 * b03 - a32 * b00;\n  out[15] = a20 * b03 - a21 * b01 + a22 * b00;\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a) {\n  let a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  let a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  let a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  let a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15];\n\n  let b0 = a00 * a11 - a01 * a10;\n  let b1 = a00 * a12 - a02 * a10;\n  let b2 = a01 * a12 - a02 * a11;\n  let b3 = a20 * a31 - a21 * a30;\n  let b4 = a20 * a32 - a22 * a30;\n  let b5 = a21 * a32 - a22 * a31;\n  let b6 = a00 * b5 - a01 * b4 + a02 * b3;\n  let b7 = a10 * b5 - a11 * b4 + a12 * b3;\n  let b8 = a20 * b2 - a21 * b1 + a22 * b0;\n  let b9 = a30 * b2 - a31 * b1 + a32 * b0;\n\n  // Calculate the determinant\n  return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;\n}\n\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\nexport function multiply(out, a, b) {\n  let a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  let a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  let a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  let a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15];\n\n  // Cache only the current line of the second matrix\n  let b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\nexport function translate(out, a, v) {\n  let x = v[0],\n    y = v[1],\n    z = v[2];\n  let a00, a01, a02, a03;\n  let a10, a11, a12, a13;\n  let a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nexport function scale(out, a, v) {\n  let x = v[0],\n    y = v[1],\n    z = v[2];\n\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nexport function rotate(out, a, rad, axis) {\n  let x = axis[0],\n    y = axis[1],\n    z = axis[2];\n  let len = Math.hypot(x, y, z);\n  let s, c, t;\n  let a00, a01, a02, a03;\n  let a10, a11, a12, a13;\n  let a20, a21, a22, a23;\n  let b00, b01, b02;\n  let b10, b11, b12;\n  let b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11];\n\n  // Construct the elements of the rotation matrix\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c;\n\n  // Perform rotation-specific matrix multiplication\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n  return out;\n}\n\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function rotateX(out, a, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  let a10 = a[4];\n  let a11 = a[5];\n  let a12 = a[6];\n  let a13 = a[7];\n  let a20 = a[8];\n  let a21 = a[9];\n  let a22 = a[10];\n  let a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  // Perform axis-specific matrix multiplication\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function rotateY(out, a, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  let a00 = a[0];\n  let a01 = a[1];\n  let a02 = a[2];\n  let a03 = a[3];\n  let a20 = a[8];\n  let a21 = a[9];\n  let a22 = a[10];\n  let a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  // Perform axis-specific matrix multiplication\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function rotateZ(out, a, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  let a00 = a[0];\n  let a01 = a[1];\n  let a02 = a[2];\n  let a03 = a[3];\n  let a10 = a[4];\n  let a11 = a[5];\n  let a12 = a[6];\n  let a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  // Perform axis-specific matrix multiplication\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nexport function fromRotation(out, rad, axis) {\n  let x = axis[0],\n    y = axis[1],\n    z = axis[2];\n  let len = Math.hypot(x, y, z);\n  let s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n\n  // Perform rotation-specific matrix multiplication\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function fromXRotation(out, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n\n  // Perform axis-specific matrix multiplication\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function fromYRotation(out, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n\n  // Perform axis-specific matrix multiplication\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nexport function fromZRotation(out, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n\n  // Perform axis-specific matrix multiplication\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  let x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let xy = x * y2;\n  let xz = x * z2;\n  let yy = y * y2;\n  let yz = y * z2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\nexport function fromQuat2(out, a) {\n  let translation = new glMatrix.ARRAY_TYPE(3);\n  let bx = -a[0],\n    by = -a[1],\n    bz = -a[2],\n    bw = a[3],\n    ax = a[4],\n    ay = a[5],\n    az = a[6],\n    aw = a[7];\n\n  let magnitude = bx * bx + by * by + bz * bz + bw * bw;\n  //Only scale if it makes sense\n  if (magnitude > 0) {\n    translation[0] = ((ax * bw + aw * bx + ay * bz - az * by) * 2) / magnitude;\n    translation[1] = ((ay * bw + aw * by + az * bx - ax * bz) * 2) / magnitude;\n    translation[2] = ((az * bw + aw * bz + ax * by - ay * bx) * 2) / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n\n  return out;\n}\n\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nexport function getScaling(out, mat) {\n  let m11 = mat[0];\n  let m12 = mat[1];\n  let m13 = mat[2];\n  let m21 = mat[4];\n  let m22 = mat[5];\n  let m23 = mat[6];\n  let m31 = mat[8];\n  let m32 = mat[9];\n  let m33 = mat[10];\n\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n\n  return out;\n}\n\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\nexport function getRotation(out, mat) {\n  let scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n\n  let is1 = 1 / scaling[0];\n  let is2 = 1 / scaling[1];\n  let is3 = 1 / scaling[2];\n\n  let sm11 = mat[0] * is1;\n  let sm12 = mat[1] * is2;\n  let sm13 = mat[2] * is3;\n  let sm21 = mat[4] * is1;\n  let sm22 = mat[5] * is2;\n  let sm23 = mat[6] * is3;\n  let sm31 = mat[8] * is1;\n  let sm32 = mat[9] * is2;\n  let sm33 = mat[10] * is3;\n\n  let trace = sm11 + sm22 + sm33;\n  let S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n\n/**\n * Decomposes a transformation matrix into its rotation, translation\n * and scale components. Returns only the rotation component\n * @param  {quat} out_r Quaternion to receive the rotation component\n * @param  {vec3} out_t Vector to receive the translation vector\n * @param  {vec3} out_s Vector to receive the scaling factor\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @returns {quat} out_r\n */\nexport function decompose(out_r, out_t, out_s, mat) {\n  out_t[0] = mat[12];\n  out_t[1] = mat[13];\n  out_t[2] = mat[14];\n\n  let m11 = mat[0];\n  let m12 = mat[1];\n  let m13 = mat[2];\n  let m21 = mat[4];\n  let m22 = mat[5];\n  let m23 = mat[6];\n  let m31 = mat[8];\n  let m32 = mat[9];\n  let m33 = mat[10];\n\n  out_s[0] = Math.hypot(m11, m12, m13);\n  out_s[1] = Math.hypot(m21, m22, m23);\n  out_s[2] = Math.hypot(m31, m32, m33);\n\n  let is1 = 1 / out_s[0];\n  let is2 = 1 / out_s[1];\n  let is3 = 1 / out_s[2];\n\n  let sm11 = m11 * is1;\n  let sm12 = m12 * is2;\n  let sm13 = m13 * is3;\n  let sm21 = m21 * is1;\n  let sm22 = m22 * is2;\n  let sm23 = m23 * is3;\n  let sm31 = m31 * is1;\n  let sm32 = m32 * is2;\n  let sm33 = m33 * is3;\n\n  let trace = sm11 + sm22 + sm33;\n  let S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out_r[3] = 0.25 * S;\n    out_r[0] = (sm23 - sm32) / S;\n    out_r[1] = (sm31 - sm13) / S;\n    out_r[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out_r[3] = (sm23 - sm32) / S;\n    out_r[0] = 0.25 * S;\n    out_r[1] = (sm12 + sm21) / S;\n    out_r[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out_r[3] = (sm31 - sm13) / S;\n    out_r[0] = (sm12 + sm21) / S;\n    out_r[1] = 0.25 * S;\n    out_r[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out_r[3] = (sm12 - sm21) / S;\n    out_r[0] = (sm31 + sm13) / S;\n    out_r[1] = (sm23 + sm32) / S;\n    out_r[2] = 0.25 * S;\n  }\n\n  return out_r;\n}\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  let x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let xy = x * y2;\n  let xz = x * z2;\n  let yy = y * y2;\n  let yz = y * z2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n  let sx = s[0];\n  let sy = s[1];\n  let sz = s[2];\n\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  let x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let xy = x * y2;\n  let xz = x * z2;\n  let yy = y * y2;\n  let yz = y * z2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n\n  let sx = s[0];\n  let sy = s[1];\n  let sz = s[2];\n\n  let ox = o[0];\n  let oy = o[1];\n  let oz = o[2];\n\n  let out0 = (1 - (yy + zz)) * sx;\n  let out1 = (xy + wz) * sx;\n  let out2 = (xz - wy) * sx;\n  let out4 = (xy - wz) * sy;\n  let out5 = (1 - (xx + zz)) * sy;\n  let out6 = (yz + wx) * sy;\n  let out8 = (xz + wy) * sz;\n  let out9 = (yz - wx) * sz;\n  let out10 = (1 - (xx + yy)) * sz;\n\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\nexport function fromQuat(out, q) {\n  let x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let yx = y * x2;\n  let yy = y * y2;\n  let zx = z * x2;\n  let zy = z * y2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function frustum(out, left, right, bottom, top, near, far) {\n  let rl = 1 / (right - left);\n  let tb = 1 / (top - bottom);\n  let nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\nexport function perspectiveNO(out, fovy, aspect, near, far) {\n  const f = 1.0 / Math.tan(fovy / 2);\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n  if (far != null && far !== Infinity) {\n    const nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n  return out;\n}\n\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\nexport const perspective = perspectiveNO;\n\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\nexport function perspectiveZO(out, fovy, aspect, near, far) {\n  const f = 1.0 / Math.tan(fovy / 2);\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n  if (far != null && far !== Infinity) {\n    const nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n  return out;\n}\n\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  let upTan = Math.tan((fov.upDegrees * Math.PI) / 180.0);\n  let downTan = Math.tan((fov.downDegrees * Math.PI) / 180.0);\n  let leftTan = Math.tan((fov.leftDegrees * Math.PI) / 180.0);\n  let rightTan = Math.tan((fov.rightDegrees * Math.PI) / 180.0);\n  let xScale = 2.0 / (leftTan + rightTan);\n  let yScale = 2.0 / (upTan + downTan);\n\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = (far * near) / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function orthoNO(out, left, right, bottom, top, near, far) {\n  const lr = 1 / (left - right);\n  const bt = 1 / (bottom - top);\n  const nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\nexport const ortho = orthoNO;\n\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function orthoZO(out, left, right, bottom, top, near, far) {\n  const lr = 1 / (left - right);\n  const bt = 1 / (bottom - top);\n  const nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\nexport function lookAt(out, eye, center, up) {\n  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  let eyex = eye[0];\n  let eyey = eye[1];\n  let eyez = eye[2];\n  let upx = up[0];\n  let upy = up[1];\n  let upz = up[2];\n  let centerx = center[0];\n  let centery = center[1];\n  let centerz = center[2];\n\n  if (\n    Math.abs(eyex - centerx) < glMatrix.EPSILON &&\n    Math.abs(eyey - centery) < glMatrix.EPSILON &&\n    Math.abs(eyez - centerz) < glMatrix.EPSILON\n  ) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n\n  len = Math.hypot(y0, y1, y2);\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\nexport function targetTo(out, eye, target, up) {\n  let eyex = eye[0],\n    eyey = eye[1],\n    eyez = eye[2],\n    upx = up[0],\n    upy = up[1],\n    upz = up[2];\n\n  let z0 = eyex - target[0],\n    z1 = eyey - target[1],\n    z2 = eyez - target[2];\n\n  let len = z0 * z0 + z1 * z1 + z2 * z2;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  let x0 = upy * z2 - upz * z1,\n    x1 = upz * z0 - upx * z2,\n    x2 = upx * z1 - upy * z0;\n\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nexport function str(a) {\n  return (\n    \"mat4(\" +\n    a[0] +\n    \", \" +\n    a[1] +\n    \", \" +\n    a[2] +\n    \", \" +\n    a[3] +\n    \", \" +\n    a[4] +\n    \", \" +\n    a[5] +\n    \", \" +\n    a[6] +\n    \", \" +\n    a[7] +\n    \", \" +\n    a[8] +\n    \", \" +\n    a[9] +\n    \", \" +\n    a[10] +\n    \", \" +\n    a[11] +\n    \", \" +\n    a[12] +\n    \", \" +\n    a[13] +\n    \", \" +\n    a[14] +\n    \", \" +\n    a[15] +\n    \")\"\n  );\n}\n\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nexport function frob(a) {\n  return Math.hypot(\n    a[0],\n    a[1],\n    a[2],\n    a[3],\n    a[4],\n    a[5],\n    a[6],\n    a[7],\n    a[8],\n    a[9],\n    a[10],\n    a[11],\n    a[12],\n    a[13],\n    a[14],\n    a[15]\n  );\n}\n\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n  return (\n    a[0] === b[0] &&\n    a[1] === b[1] &&\n    a[2] === b[2] &&\n    a[3] === b[3] &&\n    a[4] === b[4] &&\n    a[5] === b[5] &&\n    a[6] === b[6] &&\n    a[7] === b[7] &&\n    a[8] === b[8] &&\n    a[9] === b[9] &&\n    a[10] === b[10] &&\n    a[11] === b[11] &&\n    a[12] === b[12] &&\n    a[13] === b[13] &&\n    a[14] === b[14] &&\n    a[15] === b[15]\n  );\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function equals(a, b) {\n  let a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3];\n  let a4 = a[4],\n    a5 = a[5],\n    a6 = a[6],\n    a7 = a[7];\n  let a8 = a[8],\n    a9 = a[9],\n    a10 = a[10],\n    a11 = a[11];\n  let a12 = a[12],\n    a13 = a[13],\n    a14 = a[14],\n    a15 = a[15];\n\n  let b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3];\n  let b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7];\n  let b8 = b[8],\n    b9 = b[9],\n    b10 = b[10],\n    b11 = b[11];\n  let b12 = b[12],\n    b13 = b[13],\n    b14 = b[14],\n    b15 = b[15];\n\n  return (\n    Math.abs(a0 - b0) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n    Math.abs(a1 - b1) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n    Math.abs(a2 - b2) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n    Math.abs(a3 - b3) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n    Math.abs(a4 - b4) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n    Math.abs(a5 - b5) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n    Math.abs(a6 - b6) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n    Math.abs(a7 - b7) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&\n    Math.abs(a8 - b8) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&\n    Math.abs(a9 - b9) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&\n    Math.abs(a10 - b10) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&\n    Math.abs(a11 - b11) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&\n    Math.abs(a12 - b12) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&\n    Math.abs(a13 - b13) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&\n    Math.abs(a14 - b14) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&\n    Math.abs(a15 - b15) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15))\n  );\n}\n\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\nexport const mul = multiply;\n\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\nexport const sub = subtract;\n","import * as glMatrix from \"./common.js\";\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nexport function create() {\n  let out = new glMatrix.ARRAY_TYPE(3);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  return Math.hypot(x, y, z);\n}\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nexport function fromValues(x, y, z) {\n  let out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  return x * x + y * y + z * z;\n}\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\nexport function normalize(out, a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let len = x * x + y * y + z * z;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function cross(out, a, b) {\n  let ax = a[0],\n    ay = a[1],\n    az = a[2];\n  let bx = b[0],\n    by = b[1],\n    bz = b[2];\n\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nexport function lerp(out, a, b, t) {\n  let ax = a[0];\n  let ay = a[1];\n  let az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nexport function slerp(out, a, b, t) {\n  let angle = Math.acos(Math.min(Math.max(dot(a, b), -1), 1));\n  let sinTotal = Math.sin(angle);\n\n  let ratioA = Math.sin((1 - t) * angle) / sinTotal;\n  let ratioB = Math.sin(t * angle) / sinTotal;\n  out[0] = ratioA * a[0] + ratioB * b[0];\n  out[1] = ratioA * a[1] + ratioB * b[1];\n  out[2] = ratioA * a[2] + ratioB * b[2];\n\n  return out;\n}\n\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nexport function hermite(out, a, b, c, d, t) {\n  let factorTimes2 = t * t;\n  let factor1 = factorTimes2 * (2 * t - 3) + 1;\n  let factor2 = factorTimes2 * (t - 2) + t;\n  let factor3 = factorTimes2 * (t - 1);\n  let factor4 = factorTimes2 * (3 - 2 * t);\n\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n\n  return out;\n}\n\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nexport function bezier(out, a, b, c, d, t) {\n  let inverseFactor = 1 - t;\n  let inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  let factorTimes2 = t * t;\n  let factor1 = inverseFactorTimesTwo * inverseFactor;\n  let factor2 = 3 * t * inverseFactorTimesTwo;\n  let factor3 = 3 * factorTimes2 * inverseFactor;\n  let factor4 = factorTimes2 * t;\n\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned\n * @returns {vec3} out\n */\nexport function random(out, scale) {\n  scale = scale || 1.0;\n\n  let r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  let z = glMatrix.RANDOM() * 2.0 - 1.0;\n  let zScale = Math.sqrt(1.0 - z * z) * scale;\n\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat4(out, a, m) {\n  let x = a[0],\n    y = a[1],\n    z = a[2];\n  let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat3(out, a, m) {\n  let x = a[0],\n    y = a[1],\n    z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  let qx = q[0],\n    qy = q[1],\n    qz = q[2],\n    qw = q[3];\n  let x = a[0],\n    y = a[1],\n    z = a[2];\n  // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n  let uvx = qy * z - qz * y,\n    uvy = qz * x - qx * z,\n    uvz = qx * y - qy * x;\n  // var uuv = vec3.cross([], qvec, uv);\n  let uuvx = qy * uvz - qz * uvy,\n    uuvy = qz * uvx - qx * uvz,\n    uuvz = qx * uvy - qy * uvx;\n  // vec3.scale(uv, uv, 2 * w);\n  let w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2;\n  // vec3.scale(uuv, uuv, 2);\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2;\n  // return vec3.add(out, a, vec3.add(out, uv, uuv));\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\nexport function rotateX(out, a, b, rad) {\n  let p = [],\n    r = [];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n\n  return out;\n}\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\nexport function rotateY(out, a, b, rad) {\n  let p = [],\n    r = [];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n\n  return out;\n}\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\nexport function rotateZ(out, a, b, rad) {\n  let p = [],\n    r = [];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2];\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n\n  return out;\n}\n\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\nexport function angle(a, b) {\n  let ax = a[0],\n    ay = a[1],\n    az = a[2],\n    bx = b[0],\n    by = b[1],\n    bz = b[2],\n    mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)),\n    cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function equals(a, b) {\n  let a0 = a[0],\n    a1 = a[1],\n    a2 = a[2];\n  let b0 = b[0],\n    b1 = b[1],\n    b2 = b[2];\n  return (\n    Math.abs(a0 - b0) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n    Math.abs(a1 - b1) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n    Math.abs(a2 - b2) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2))\n  );\n}\n\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\nexport const sub = subtract;\n\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\nexport const mul = multiply;\n\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\nexport const div = divide;\n\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\nexport const dist = distance;\n\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\nexport const sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec3.length}\n * @function\n */\nexport const len = length;\n\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\nexport const sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nexport const forEach = (function () {\n  let vec = create();\n\n  return function (a, stride, offset, count, fn, arg) {\n    let i, l;\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n})();\n","import * as glMatrix from \"./common.js\";\n\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\nexport function create() {\n  let out = new glMatrix.ARRAY_TYPE(4);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\nexport function clone(a) {\n  let out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\nexport function fromValues(x, y, z, w) {\n  let out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  let w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  let w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\nexport function normalize(out, a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let w = a[3];\n  let len = x * x + y * y + z * z + w * w;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} result the receiving vector\n * @param {ReadonlyVec4} U the first vector\n * @param {ReadonlyVec4} V the second vector\n * @param {ReadonlyVec4} W the third vector\n * @returns {vec4} result\n */\nexport function cross(out, u, v, w) {\n  let A = v[0] * w[1] - v[1] * w[0],\n    B = v[0] * w[2] - v[2] * w[0],\n    C = v[0] * w[3] - v[3] * w[0],\n    D = v[1] * w[2] - v[2] * w[1],\n    E = v[1] * w[3] - v[3] * w[1],\n    F = v[2] * w[3] - v[3] * w[2];\n  let G = u[0];\n  let H = u[1];\n  let I = u[2];\n  let J = u[3];\n\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\nexport function lerp(out, a, b, t) {\n  let ax = a[0];\n  let ay = a[1];\n  let az = a[2];\n  let aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned\n * @returns {vec4} out\n */\nexport function random(out, scale) {\n  scale = scale || 1.0;\n\n  // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n  var v1, v2, v3, v4;\n  var s1, s2;\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\nexport function transformMat4(out, a, m) {\n  let x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\nexport function transformQuat(out, a, q) {\n  let x = a[0],\n    y = a[1],\n    z = a[2];\n  let qx = q[0],\n    qy = q[1],\n    qz = q[2],\n    qw = q[3];\n\n  // calculate quat * vec\n  let ix = qw * x + qy * z - qz * y;\n  let iy = qw * y + qz * x - qx * z;\n  let iz = qw * z + qx * y - qy * x;\n  let iw = -qx * x - qy * y - qz * z;\n\n  // calculate result * inverse quat\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function equals(a, b) {\n  let a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3];\n  let b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3];\n  return (\n    Math.abs(a0 - b0) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n    Math.abs(a1 - b1) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n    Math.abs(a2 - b2) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n    Math.abs(a3 - b3) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3))\n  );\n}\n\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\nexport const sub = subtract;\n\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\nexport const mul = multiply;\n\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\nexport const div = divide;\n\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\nexport const dist = distance;\n\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\nexport const sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec4.length}\n * @function\n */\nexport const len = length;\n\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\nexport const sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nexport const forEach = (function() {\n  let vec = create();\n\n  return function(a, stride, offset, count, fn, arg) {\n    let i, l;\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n})();\n","import * as glMatrix from \"./common.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\n\n/**\n * Quaternion in the format XYZW\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\nexport function create() {\n  let out = new glMatrix.ARRAY_TYPE(4);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyVec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nexport function setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  let s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\nexport function getAxisAngle(out_axis, q) {\n  let rad = Math.acos(q[3]) * 2.0;\n  let s = Math.sin(rad / 2.0);\n  if (s > glMatrix.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n  return rad;\n}\n\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param  {ReadonlyQuat} a     Origin unit quaternion\n * @param  {ReadonlyQuat} b     Destination unit quaternion\n * @return {Number}     Angle, in radians, between the two quaternions\n */\nexport function getAngle(a, b) {\n  let dotproduct = dot(a, b);\n\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n */\nexport function multiply(out, a, b) {\n  let ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  let bx = b[0],\n    by = b[1],\n    bz = b[2],\n    bw = b[3];\n\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateX(out, a, rad) {\n  rad *= 0.5;\n\n  let ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  let bx = Math.sin(rad),\n    bw = Math.cos(rad);\n\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateY(out, a, rad) {\n  rad *= 0.5;\n\n  let ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  let by = Math.sin(rad),\n    bw = Math.cos(rad);\n\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateZ(out, a, rad) {\n  rad *= 0.5;\n\n  let ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  let bz = Math.sin(rad),\n    bw = Math.cos(rad);\n\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate W component of\n * @returns {quat} out\n */\nexport function calculateW(out, a) {\n  let x = a[0],\n    y = a[1],\n    z = a[2];\n\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n\n/**\n * Calculate the exponential of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\nexport function exp(out, a) {\n  let x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n\n  let r = Math.sqrt(x * x + y * y + z * z);\n  let et = Math.exp(w);\n  let s = r > 0 ? (et * Math.sin(r)) / r : 0;\n\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n\n  return out;\n}\n\n/**\n * Calculate the natural logarithm of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\nexport function ln(out, a) {\n  let x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n\n  let r = Math.sqrt(x * x + y * y + z * z);\n  let t = r > 0 ? Math.atan2(r, w) / r : 0;\n\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n\n  return out;\n}\n\n/**\n * Calculate the scalar power of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @param {Number} b amount to scale the quaternion by\n * @returns {quat} out\n */\nexport function pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  let ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  let bx = b[0],\n    by = b[1],\n    bz = b[2],\n    bw = b[3];\n\n  let omega, cosom, sinom, scale0, scale1;\n\n  // calc cosine\n  cosom = ax * bx + ay * by + az * bz + aw * bw;\n  // adjust signs (if necessary)\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  }\n  // calculate coefficients\n  if (1.0 - cosom > glMatrix.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n  // calculate final values\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n\n  return out;\n}\n\n/**\n * Generates a random unit quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  let u1 = glMatrix.RANDOM();\n  let u2 = glMatrix.RANDOM();\n  let u3 = glMatrix.RANDOM();\n\n  let sqrt1MinusU1 = Math.sqrt(1 - u1);\n  let sqrtU1 = Math.sqrt(u1);\n\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate inverse of\n * @returns {quat} out\n */\nexport function invert(out, a) {\n  let a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3];\n  let dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  let invDot = dot ? 1.0 / dot : 0;\n\n  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyMat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nexport function fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  let fTrace = m[0] + m[4] + m[8];\n  let fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    let i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    let j = (i + 1) % 3;\n    let k = (i + 2) % 3;\n\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @param {quat} out the receiving quaternion\n * @param {x} x Angle to rotate around X axis in degrees.\n * @param {y} y Angle to rotate around Y axis in degrees.\n * @param {z} z Angle to rotate around Z axis in degrees.\n * @param {'zyx'|'xyz'|'yxz'|'yzx'|'zxy'|'zyx'} order Intrinsic order for conversion, default is zyx.\n * @returns {quat} out\n * @function\n */\nexport function fromEuler(out, x, y, z, order = glMatrix.ANGLE_ORDER) {\n  let halfToRad = Math.PI / 360;\n  x *= halfToRad;\n  z *= halfToRad;\n  y *= halfToRad;\n\n  let sx = Math.sin(x);\n  let cx = Math.cos(x);\n  let sy = Math.sin(y);\n  let cy = Math.cos(y);\n  let sz = Math.sin(z);\n  let cz = Math.cos(z);\n\n  switch (order) {\n    case \"xyz\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n\n    case \"xzy\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n\n    case \"yxz\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n\n    case \"yzx\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n\n    case \"zxy\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n\n    case \"zyx\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n\n    default:\n      throw new Error('Unknown angle order ' + order);\n  }\n\n  return out;\n}\n\n/**\n * Returns a string representation of a quaternion\n *\n * @param {ReadonlyQuat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a) {\n  return \"quat(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\nexport const clone = vec4.clone;\n\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\nexport const fromValues = vec4.fromValues;\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nexport const copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nexport const set = vec4.set;\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n * @function\n */\nexport const add = vec4.add;\n\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\nexport const mul = multiply;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {ReadonlyQuat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nexport const scale = vec4.scale;\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nexport const dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\nexport const lerp = vec4.lerp;\n\n/**\n * Calculates the length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport const length = vec4.length;\n\n/**\n * Alias for {@link quat.length}\n * @function\n */\nexport const len = length;\n\n/**\n * Calculates the squared length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nexport const squaredLength = vec4.squaredLength;\n\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\nexport const sqrLen = squaredLength;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nexport const normalize = vec4.normalize;\n\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat} a The first quaternion.\n * @param {ReadonlyQuat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport const exactEquals = vec4.exactEquals;\n\n/**\n * Returns whether or not the quaternions point approximately to the same direction.\n *\n * Both quaternions are assumed to be unit length.\n *\n * @param {ReadonlyQuat} a The first unit quaternion.\n * @param {ReadonlyQuat} b The second unit quaternion.\n * @returns {Boolean} True if the quaternions are equal, false otherwise.\n */\nexport function equals(a, b) {\n    return Math.abs(vec4.dot(a, b)) >= 1 - glMatrix.EPSILON;\n}\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {ReadonlyVec3} a the initial vector\n * @param {ReadonlyVec3} b the destination vector\n * @returns {quat} out\n */\nexport const rotationTo = (function () {\n  let tmpvec3 = vec3.create();\n  let xUnitVec3 = vec3.fromValues(1, 0, 0);\n  let yUnitVec3 = vec3.fromValues(0, 1, 0);\n\n  return function (out, a, b) {\n    let dot = vec3.dot(a, b);\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n})();\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {ReadonlyQuat} c the third operand\n * @param {ReadonlyQuat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport const sqlerp = (function () {\n  let temp1 = create();\n  let temp2 = create();\n\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n\n    return out;\n  };\n})();\n\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\nexport const setAxes = (function () {\n  let matr = mat3.create();\n\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n\n    return normalize(out, fromMat3(out, matr));\n  };\n})();\n","import * as glMatrix from \"./common.js\";\n\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\nexport function create() {\n  let out = new glMatrix.ARRAY_TYPE(2);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\nexport function clone(a) {\n  let out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\nexport function fromValues(x, y) {\n  let out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return x * x + y * y;\n}\n\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n  var x = a[0],\n    y = a[1];\n  return Math.hypot(x, y);\n}\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n  var x = a[0],\n    y = a[1];\n  return x * x + y * y;\n}\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\nexport function normalize(out, a) {\n  var x = a[0],\n    y = a[1];\n  var len = x * x + y * y;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\nexport function cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n    ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned\n * @returns {vec2} out\n */\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat4(out, a, m) {\n  let x = a[0];\n  let y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\n export function rotateA(out, a, c) {\n  let r = [];\n  r[0] = a[0] * Math.cos(c) - a[1] * Math.sin(c);\n  r[1] = a[0] * Math.sin(c) + a[1] * Math.cos(c);\n  out[0] = r[0];\n  out[1] = r[1];\n  return r;\n}\n\nexport function rotate(out, a, b, rad) {\n  //Translate point to the origin\n  let p0 = a[0] - b[0],\n    p1 = a[1] - b[1],\n    sinC = Math.sin(rad),\n    cosC = Math.cos(rad);\n\n  //perform rotation and translate to correct position\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n\n  return out;\n}\n\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\nexport function angle(a, b) {\n  let x1 = a[0],\n    y1 = a[1],\n    x2 = b[0],\n    y2 = b[1],\n    // mag is the product of the magnitudes of a and b\n    mag = Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)),\n    // mag &&.. short circuits if mag == 0\n    cosine = mag && (x1 * x2 + y1 * y2) / mag;\n  // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n\n\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function equals(a, b) {\n  let a0 = a[0],\n    a1 = a[1];\n  let b0 = b[0],\n    b1 = b[1];\n  return (\n    Math.abs(a0 - b0) <=\n    glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n    Math.abs(a1 - b1) <=\n    glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1))\n  );\n}\n\n/**\n * Alias for {@link vec2.length}\n * @function\n */\nexport const len = length;\n\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\nexport const sub = subtract;\n\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\nexport const mul = multiply;\n\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\nexport const div = divide;\n\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\nexport const dist = distance;\n\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\nexport const sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\nexport const sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nexport const forEach = (function () {\n  let vec = create();\n\n  return function (a, stride, offset, count, fn, arg) {\n    let i, l;\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n})();\n","import * as glMatrix from \"./common.js\";\n\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\nexport function create() {\n  let out = new glMatrix.ARRAY_TYPE(9);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nexport function fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\nexport function clone(a) {\n  let out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  let out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    let a01 = a[1],\n      a02 = a[2],\n      a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function invert(out, a) {\n  let a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  let a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  let a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n\n  let b01 = a22 * a11 - a12 * a21;\n  let b11 = -a22 * a10 + a12 * a20;\n  let b21 = a21 * a10 - a11 * a20;\n\n  // Calculate the determinant\n  let det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function adjoint(out, a) {\n  let a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  let a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  let a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a) {\n  let a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  let a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  let a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n\n  return (\n    a00 * (a22 * a11 - a12 * a21) +\n    a01 * (-a22 * a10 + a12 * a20) +\n    a02 * (a21 * a10 - a11 * a20)\n  );\n}\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\nexport function multiply(out, a, b) {\n  let a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  let a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  let a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n\n  let b00 = b[0],\n    b01 = b[1],\n    b02 = b[2];\n  let b10 = b[3],\n    b11 = b[4],\n    b12 = b[5];\n  let b20 = b[6],\n    b21 = b[7],\n    b22 = b[8];\n\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\nexport function translate(out, a, v) {\n  let a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a10 = a[3],\n    a11 = a[4],\n    a12 = a[5],\n    a20 = a[6],\n    a21 = a[7],\n    a22 = a[8],\n    x = v[0],\n    y = v[1];\n\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nexport function rotate(out, a, rad) {\n  let a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a10 = a[3],\n    a11 = a[4],\n    a12 = a[5],\n    a20 = a[6],\n    a21 = a[7],\n    a22 = a[8],\n    s = Math.sin(rad),\n    c = Math.cos(rad);\n\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nexport function scale(out, a, v) {\n  let x = v[0],\n    y = v[1];\n\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nexport function fromRotation(out, rad) {\n  let s = Math.sin(rad),\n    c = Math.cos(rad);\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\nexport function fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\nexport function fromQuat(out, q) {\n  let x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let yx = y * x2;\n  let yy = y * y2;\n  let zx = z * x2;\n  let zy = z * y2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n\n  return out;\n}\n\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\nexport function normalFromMat4(out, a) {\n  let a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  let a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  let a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  let a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  // Calculate the determinant\n  let det =\n    b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n  return out;\n}\n\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\nexport function projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nexport function str(a) {\n  return (\n    \"mat3(\" +\n    a[0] +\n    \", \" +\n    a[1] +\n    \", \" +\n    a[2] +\n    \", \" +\n    a[3] +\n    \", \" +\n    a[4] +\n    \", \" +\n    a[5] +\n    \", \" +\n    a[6] +\n    \", \" +\n    a[7] +\n    \", \" +\n    a[8] +\n    \")\"\n  );\n}\n\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n  return (\n    a[0] === b[0] &&\n    a[1] === b[1] &&\n    a[2] === b[2] &&\n    a[3] === b[3] &&\n    a[4] === b[4] &&\n    a[5] === b[5] &&\n    a[6] === b[6] &&\n    a[7] === b[7] &&\n    a[8] === b[8]\n  );\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function equals(a, b) {\n  let a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3],\n    a4 = a[4],\n    a5 = a[5],\n    a6 = a[6],\n    a7 = a[7],\n    a8 = a[8];\n  let b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3],\n    b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7],\n    b8 = b[8];\n  return (\n    Math.abs(a0 - b0) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n    Math.abs(a1 - b1) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n    Math.abs(a2 - b2) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n    Math.abs(a3 - b3) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n    Math.abs(a4 - b4) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n    Math.abs(a5 - b5) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n    Math.abs(a6 - b6) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n    Math.abs(a7 - b7) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&\n    Math.abs(a8 - b8) <=\n      glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8))\n  );\n}\n\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\nexport const mul = multiply;\n\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\nexport const sub = subtract;\n","import {vec3 } from \"../Lib/gl-matrix\";\r\n\r\nclass ShaderLightAtIndex {\r\n    constructor(gEngine, shader, index) {\r\n        this.gEngine = gEngine;\r\n        this._setShaderReferences(shader, index);\r\n    };\r\n\r\n    loadToShader(aCamera, aLight) {\r\n        let gl = this.gEngine.Core.getGL();\r\n        gl.uniform1i(this.mIsOnRef, aLight.isLightOn());\r\n        if (aLight.isLightOn()) {\r\n            var p = aCamera.wcPosToPixel(aLight.getPosition());\r\n            var ic = aCamera.wcSizeToPixel(aLight.getNear());\r\n            var oc = aCamera.wcSizeToPixel(aLight.getFar());\r\n            var c = aLight.getColor();\r\n            gl.uniform4fv(this.mColorRef, c);\r\n            gl.uniform3fv(this.mPosRef, vec3.fromValues(p[0], p[1], p[2]));\r\n            gl.uniform1f(this.mNearRef, ic);\r\n            gl.uniform1f(this.mFarRef, oc);\r\n            gl.uniform1f(this.mIntensityRef, aLight.getIntensity());\r\n        }\r\n    };\r\n\r\n    switchOffLight = function () {\r\n        let gl = this.gEngine.Core.getGL();\r\n        gl.uniform1i(this.mIsOnRef, false);\r\n    };\r\n\r\n    _setShaderReferences(aLightShader, index) {\r\n        let gl = this.gEngine.Core.getGL();\r\n        this.mColorRef = gl.getUniformLocation(aLightShader,      \"uLights[\" + index + \"].Color\");\r\n        this.mPosRef = gl.getUniformLocation(aLightShader,        \"uLights[\" + index + \"].Position\");\r\n        this.mNearRef = gl.getUniformLocation(aLightShader,       \"uLights[\" + index + \"].Near\");\r\n        this.mFarRef = gl.getUniformLocation(aLightShader,        \"uLights[\" + index + \"].Far\");\r\n        this.mIntensityRef = gl.getUniformLocation(aLightShader,  \"uLights[\" + index + \"].Intensity\");\r\n        this.mIsOnRef = gl.getUniformLocation(aLightShader,       \"uLights[\" + index + \"].IsOn\");\r\n    };\r\n}\r\n\r\n\r\nexport { ShaderLightAtIndex };","import { SpriteShader } from \"./SpriteShader\";\r\nimport { vec3 } from \"../Lib/gl-matrix\";\r\nimport { ShaderLightAtIndex } from \"./ShaderLightAtIndex\";\r\n\r\nclass LightShader extends SpriteShader {\r\n    constructor(gEngine, vertexShaderPath, fragmentShaderPath) {\r\n        super(gEngine, vertexShaderPath, fragmentShaderPath);\r\n\r\n        // // glsl uniform position references\r\n        // this.mColorRef = null;\r\n        // this.mPosRef = null;\r\n        // this.mRadiusRef = null;\r\n        // this.mIsOnRef = null;\r\n\r\n        this.mLights = null; // <-- this is the light source in the Game Engine\r\n\r\n        //*******WARNING***************\r\n        // this number MUST correspond to the GLSL uLight[] array size (for LightFS.glsl)\r\n        //*******WARNING********************\r\n        this.kGLSLuLightArraySize = 4;  // <-- make sure this is the same as LightFS.glsl\r\n        this.mShaderLights = [];\r\n\r\n        let i, ls;\r\n        for (i = 0; i < this.kGLSLuLightArraySize; i++) {\r\n            ls = new ShaderLightAtIndex(gEngine, this.mCompiledShader, i);\r\n            this.mShaderLights.push(ls);\r\n        }\r\n    };\r\n\r\n    activateShader(pixelColor, aCamera) {\r\n        // first call the super class's activate\r\n        super.activateShader(pixelColor, aCamera);\r\n\r\n        // now push the light information to the shader\r\n        let numLight = 0;\r\n        if (this.mLights !== null) {\r\n            while (numLight < this.mLights.length) {\r\n                this.mShaderLights[numLight].loadToShader(aCamera, this.mLights[numLight]);\r\n                numLight++;\r\n            }\r\n        }\r\n        // switch off the left over ones.\r\n        while (numLight < this.kGLSLuLightArraySize) {\r\n            this.mShaderLights[numLight].switchOffLight(); // switch off unused lights\r\n            numLight++;\r\n        }\r\n    };\r\n\r\n    setLights(l) {\r\n        this.mLights = l;\r\n    };\r\n\r\n\r\n\r\n}\r\n\r\nexport { LightShader }","import { TextureShader } from \"../../Shaders/TextureShader\";\r\nimport { SimpleShader } from \"../../Shaders/SimpleShader\";\r\nimport { SpriteShader } from \"../../Shaders/SpriteShader\";\r\nimport { LineShader } from \"../../Shaders/LineShader\";\r\nimport { LightShader } from \"../../Shaders/LightShader\";\r\nimport { vec4 } from \"../../Lib/gl-matrix\";\r\n\r\n\r\nclass DefaultResources {\r\n    constructor(gEngine) {\r\n        this.gEngine = gEngine;\r\n\r\n        // Global Ambient color\r\n        this.mGlobalAmbientColor = [0.8, 0.8, 0.8, 1];\r\n        this.mGlobalAmbientIntensity = 1;\r\n\r\n        // Simple Shader\r\n        this.kSimpleVS = \"src/GLSLShaders/SimpleVS.glsl\";  // Path to the VertexShader \r\n        this.kSimpleFS = \"src/GLSLShaders/SimpleFS.glsl\";  // Path to the simple FragmentShader\r\n        this.mConstColorShader = null;\r\n\r\n        // Texture Shader\r\n        this.kTextureVS = \"src/GLSLShaders/TextureVS.glsl\";  // Path to the VertexShader \r\n        this.kTextureFS = \"src/GLSLShaders/TextureFS.glsl\";  // Path to the texture FragmentShader\r\n        this.mTextureShader = null;\r\n        this.mSpriteShader = null;\r\n        this.kLineFS = \"src/GLSLShaders/LineFS.glsl\";        // Path to the Line FragmentShader\r\n        this.mLineShader = null;\r\n\r\n        // Light Shader\r\n        this.kLightFS = \"src/GLSLShaders/LightFS.glsl\";  // Path to the Light FragmentShader\r\n        this.mLightShader = null;\r\n\r\n        // Default font\r\n        this.kDefaultFont = \"assets/fonts/system-default-font\";\r\n    }\r\n    getGlobalAmbientIntensity() { return this.mGlobalAmbientIntensity; };\r\n    setGlobalAmbientIntensity(v) { this.mGlobalAmbientIntensity = v; };\r\n    getGlobalAmbientColor() { return this.mGlobalAmbientColor; };\r\n    setGlobalAmbientColor(v) { this.mGlobalAmbientColor = vec4.fromValues(v[0], v[1], v[2], v[3]); };\r\n\r\n    getDefaultFont() { return this.kDefaultFont; };\r\n    getConstColorShader() { return this.mConstColorShader; };\r\n    getTextureShader() { return this.mTextureShader; };\r\n    getSpriteShader() { return this.mSpriteShader; };\r\n    getLineShader() { return this.mLineShader; };\r\n    getLightShader() { return this.mLightShader; };\r\n\r\n    _createShaders(callBackFunction) {\r\n        this.gEngine.ResourceMap.setLoadCompleteCallback(null);\r\n        this.mConstColorShader = new SimpleShader(this.gEngine, this.kSimpleVS, this.kSimpleFS);\r\n        this.mTextureShader = new TextureShader(this.gEngine, this.kTextureVS, this.kTextureFS);\r\n        this.mSpriteShader = new SpriteShader(this.gEngine, this.kTextureVS, this.kTextureFS);\r\n        this.mLineShader = new LineShader(this.gEngine, this.kSimpleVS, this.kLineFS);\r\n        this.mLightShader = new LightShader(this.gEngine, this.kTextureVS, this.kLightFS);\r\n        console.log(\"DefaultResources::createShader mConstColorShader\");\r\n        callBackFunction();\r\n    };\r\n\r\n    initialize(callBackFunction) {\r\n        // constant color shader: SimpleVS, and SimpleFS\r\n        this.gEngine.TextFileLoader.loadTextFile(this.kSimpleVS, this.gEngine.TextFileLoader.eTextFileType.eTextFile);\r\n        this.gEngine.TextFileLoader.loadTextFile(this.kSimpleFS, this.gEngine.TextFileLoader.eTextFileType.eTextFile);\r\n\r\n        // texture shader: \r\n        this.gEngine.TextFileLoader.loadTextFile(this.kTextureVS, this.gEngine.TextFileLoader.eTextFileType.eTextFile);\r\n        this.gEngine.TextFileLoader.loadTextFile(this.kTextureFS, this.gEngine.TextFileLoader.eTextFileType.eTextFile);\r\n        console.log(\"DefaultResources::initialize::loadTextFileofNums: \" + this.gEngine.ResourceMap.mNumOutstandingLoads);\r\n\r\n        // Line Shader:\r\n        this.gEngine.TextFileLoader.loadTextFile(this.kLineFS, this.gEngine.TextFileLoader.eTextFileType.eTextFile);\r\n\r\n        // Light Shader\r\n        this.gEngine.TextFileLoader.loadTextFile(this.kLightFS, this.gEngine.TextFileLoader.eTextFileType.eTextFile);\r\n\r\n        // load default font\r\n        this.gEngine.Fonts.loadFont(this.kDefaultFont);\r\n        this.gEngine.ResourceMap.setLoadCompleteCallback(() => { this._createShaders(callBackFunction); });\r\n    };\r\n\r\n    // unload all resources\r\n    cleanUp() {\r\n        this.mConstColorShader.cleanUp();\r\n        this.mTextureShader.cleanUp();\r\n        this.mSpriteShader.cleanUp();\r\n\r\n        this.gEngine.TextFileLoader.unloadTextFile(this.kSimpleVS);\r\n        this.gEngine.TextFileLoader.unloadTextFile(this.kSimpleFS);\r\n\r\n        // texture shader: \r\n        this.gEngine.TextFileLoader.unloadTextFile(this.kTextureVS);\r\n        this.gEngine.TextFileLoader.unloadTextFile(this.kTextureFS);\r\n\r\n        // Line Shader:\r\n        this.gEngine.TextFileLoader.unloadTextFile(this.kLineFS);\r\n\r\n        // Light Shader\r\n        this.gEngine.TextFileLoader.unloadTextFile(this.kLightFS);\r\n\r\n        // default font\r\n        this.gEngine.Fonts.unloadFont(this.kDefaultFont);\r\n    };\r\n}\r\nexport { DefaultResources }","\r\nclass CharacterInfo {\r\n    constructor() {\r\n        // in texture coordinate (0 to 1) maps to the entire image\r\n        this.mTexCoordLeft = 0;\r\n        this.mTexCoordRight = 1;\r\n        this.mTexCoordBottom = 0;\r\n        this.mTexCoordTop = 0;\r\n\r\n        // reference to nominal character size, 1 is \"standard width/height\" of a char\r\n        this.mCharWidth = 1;\r\n        this.mCharHeight = 1;\r\n        this.mCharWidthOffset = 0;\r\n        this.mCharHeightOffset = 0;\r\n        this.mXAdvance = 0;\r\n\r\n        // reference of char width/height ratio\r\n        this.mCharAspectRatio = 1;\r\n    };\r\n};\r\n\r\nclass Fonts {\r\n    constructor(gEngine) {\r\n        this.gEngine = gEngine;\r\n    }\r\n\r\n    _storeLoadedFont(fontInfoSourceString) {\r\n        var fontName = fontInfoSourceString.slice(0, -4);  // trims the .fnt extension\r\n        //console.log(\"Fonts::_storeLoadedFont:\");\r\n        var fontInfo = this.gEngine.ResourceMap.retrieveAsset(fontInfoSourceString);\r\n        fontInfo.FontImage = fontName + \".png\";\r\n        //console.log(\"Fonts::_storeLoadedFont:\"+fontInfo);\r\n        this.gEngine.ResourceMap.asyncLoadCompleted(fontName, fontInfo); // to store the actual font info\r\n    };\r\n\r\n    loadFont(fontName) {\r\n        if (!(this.gEngine.ResourceMap.isAssetLoaded(fontName))) {\r\n            var fontInfoSourceString = fontName + \".fnt\";\r\n            var textureSourceString = fontName + \".png\";\r\n            \r\n            this.gEngine.ResourceMap.asyncLoadRequested(fontName); // to register an entry in the map\r\n            console.log(\"Fonts::loadFont: \")\r\n            this.gEngine.Textures.loadTexture(textureSourceString);\r\n            this.gEngine.TextFileLoader.loadTextFile(fontInfoSourceString,\r\n                this.gEngine.TextFileLoader.eTextFileType.eXMLFile, (fontInfoSourceString) => this._storeLoadedFont(fontInfoSourceString));\r\n            \r\n        } else {\r\n            this.gEngine.ResourceMap.incAssetRefCount(fontName);\r\n        }\r\n    };\r\n\r\n    // Remove the reference to allow associated memory \r\n    // be available for subsequent garbage collection\r\n    unloadFont(fontName) {\r\n        this.gEngine.ResourceMap.unloadAsset(fontName);\r\n        if (!(this.gEngine.ResourceMap.isAssetLoaded(fontName))) {\r\n            var fontInfoSourceString = fontName + \".fnt\";\r\n            var textureSourceString = fontName + \".png\";\r\n\r\n            this.gEngine.Textures.unloadTexture(textureSourceString);\r\n            this.gEngine.TextFileLoader.unloadTextFile(fontInfoSourceString);\r\n        }\r\n    };\r\n\r\n    getCharInfo(fontName, aChar) {\r\n        var returnInfo = null;\r\n        var fontInfo = this.gEngine.ResourceMap.retrieveAsset(fontName);\r\n        var commonPath = \"font/common\";\r\n        var commonInfo = fontInfo.evaluate(commonPath, fontInfo, null, XPathResult.ANY_TYPE, null);\r\n        commonInfo = commonInfo.iterateNext();\r\n        if (commonInfo === null) {\r\n            return returnInfo;\r\n        }\r\n        var charHeight = commonInfo.getAttribute(\"base\");\r\n\r\n        var charPath = \"font/chars/char[@id=\" + aChar + \"]\";\r\n        var charInfo = fontInfo.evaluate(charPath, fontInfo, null, XPathResult.ANY_TYPE, null);\r\n        charInfo = charInfo.iterateNext();\r\n\r\n        if (charInfo === null) {\r\n            return returnInfo;\r\n        }\r\n\r\n        returnInfo = new CharacterInfo();\r\n        var texInfo = this.gEngine.Textures.getTextureInfo(fontInfo.FontImage);\r\n        var leftPixel = Number(charInfo.getAttribute(\"x\"));\r\n        var rightPixel = leftPixel + Number(charInfo.getAttribute(\"width\")) - 1;\r\n        var topPixel = (texInfo.mHeight - 1) - Number(charInfo.getAttribute(\"y\"));\r\n        var bottomPixel = topPixel - Number(charInfo.getAttribute(\"height\")) + 1;\r\n\r\n        // texture coordinate information\r\n        returnInfo.mTexCoordLeft = leftPixel / (texInfo.mWidth - 1);\r\n        returnInfo.mTexCoordTop = topPixel / (texInfo.mHeight - 1);\r\n        returnInfo.mTexCoordRight = rightPixel / (texInfo.mWidth - 1);\r\n        returnInfo.mTexCoordBottom = bottomPixel / (texInfo.mHeight - 1);\r\n\r\n        // relative character size\r\n        var charWidth = charInfo.getAttribute(\"xadvance\");\r\n        returnInfo.mXAdvance = charWidth;\r\n        returnInfo.mCharWidth = charInfo.getAttribute(\"width\") / charWidth;\r\n        returnInfo.mCharHeight = charInfo.getAttribute(\"height\") / charHeight;\r\n        returnInfo.mCharWidthOffset = charInfo.getAttribute(\"xoffset\") / charWidth;\r\n        returnInfo.mCharHeightOffset = charInfo.getAttribute(\"yoffset\") / charHeight;\r\n        returnInfo.mCharAspectRatio = charWidth / charHeight;\r\n        // console.log(\"Fonts::getCharInfo: \");\r\n        return returnInfo;\r\n    };\r\n}\r\n\r\nexport { Fonts };","// 通过抛出异常使得Scene作为抽象基类\r\nclass Scene {\r\n    constructor() {\r\n        if (new.target === Scene) {\r\n            throw new Error(\"Scene::You cant create Scene instances\");\r\n        }\r\n    }\r\n\r\n    // Begin Scene: must load all the scene contents\r\n    // when done \r\n    //  => start the GameLoop\r\n    // The game loop will call initialize and then Update/draw\r\n    loadScene() {\r\n        throw new Error(\"Scene::You have to implement the method loadScene!\");// override to load scene specific contents\r\n    };\r\n\r\n    // Performs all initialization functions\r\n    //   => Should call gEngine.GameLoop.start(this)!\r\n    initialize() {\r\n        throw new Error(\"Scene::You have to implement the method initialize!\");// initialize the level (called from GameLoop)\r\n    };\r\n\r\n    update() {\r\n        // when done with this level should call:\r\n        // GameLoop.stop() ==> which will call this.unloadScene();\r\n        throw new Error(\"Scene::You have to implement the method update!\");\r\n    };\r\n\r\n    // draw function to be called from EngineCore.GameLoop\r\n    draw() {\r\n        throw new Error(\"Scene::You have to implement the method draw!\");\r\n    };\r\n\r\n    unloadScene() {\r\n        // .. unload all resources\r\n        throw new Error(\"Scene::You have to implement the method unloadScene!\");\r\n    };\r\n}\r\n\r\nexport { Scene };","import { vec2 } from \"../Lib/gl-matrix\";\r\n\r\nclass BoundingBox {\r\n\r\n    static eboundCollideStatus = {\r\n        eCollideLeft: 1,\r\n        eCollideRight: 2,\r\n        eCollideTop: 4,\r\n        eCollideBottom: 8,\r\n        eInside: 16,\r\n        eOutside: 0\r\n    };\r\n\r\n    constructor(centerPos, w, h) {\r\n        this.mLL = vec2.fromValues(0, 0);\r\n        this.setBounds(centerPos, w, h);\r\n    };\r\n\r\n    setBounds(centerPos, w, h) {\r\n        this.mWidth = w;\r\n        this.mHeight = h;\r\n        this.mLL[0] = centerPos[0] - (w / 2);\r\n        this.mLL[1] = centerPos[1] - (h / 2);\r\n    };\r\n\r\n    containsPoint(x, y) {\r\n        return ((x > this.minX()) && (x < this.maxX()) &&\r\n            (y > this.minY()) && (y < this.maxY()));\r\n    };\r\n\r\n    intersectsBound(otherBound) {\r\n        return ((this.minX() < otherBound.maxX()) &&\r\n            (this.maxX() > otherBound.minX()) &&\r\n            (this.minY() < otherBound.maxY()) &&\r\n            (this.maxY() > otherBound.minY()));\r\n    };\r\n\r\n    boundCollideStatus(otherBound) {\r\n        let status = BoundingBox.eboundCollideStatus.eOutside;\r\n\r\n        if (this.intersectsBound(otherBound)) {\r\n            if (otherBound.minX() < this.minX()) {\r\n                status |= BoundingBox.eboundCollideStatus.eCollideLeft;\r\n            }\r\n            if (otherBound.maxX() > this.maxX()) {\r\n                status |= BoundingBox.eboundCollideStatus.eCollideRight;\r\n            }\r\n            if (otherBound.minY() < this.minY()) {\r\n                status |= BoundingBox.eboundCollideStatus.eCollideBottom;\r\n            }\r\n            if (otherBound.maxY() > this.maxY()) {\r\n                status |= BoundingBox.eboundCollideStatus.eCollideTop;\r\n            }\r\n\r\n            // if the bounds intersects and yet none of the sides overlaps\r\n            // otherBound is completely inside thisBound\r\n            if (status === BoundingBox.eboundCollideStatus.eOutside) {\r\n                status = BoundingBox.eboundCollideStatus.eInside;\r\n            }\r\n        }\r\n        return status;\r\n    };\r\n\r\n    minX() { return this.mLL[0]; };\r\n    maxX() { return this.mLL[0] + this.mWidth; };\r\n    minY() { return this.mLL[1]; };\r\n    maxY() { return this.mLL[1] + this.mHeight; };\r\n}\r\nexport { BoundingBox }","class ShakePosition {\r\n    constructor(xDelta, yDelta, shakeFrequency, shakeDuration) {\r\n        this.mXMag = xDelta;\r\n        this.mYMag = yDelta;\r\n\r\n        this.mCycles = shakeDuration; // number of cycles to complete the transition\r\n        this.mOmega = shakeFrequency * 2 * Math.PI; // Converts frequency to radians \r\n\r\n        this.mNumCyclesLeft = shakeDuration;\r\n    };\r\n\r\n    shakeDone() {\r\n        return (this.mNumCyclesLeft <= 0);\r\n    };\r\n\r\n    getShakeResults() {\r\n        this.mNumCyclesLeft--;\r\n        let c = [];\r\n        let fx = 0;\r\n        let fy = 0;\r\n        if (!this.shakeDone()) {\r\n            let v = this._nextDampedHarmonic();\r\n            fx = (Math.random() > 0.5) ? -v : v;\r\n            fy = (Math.random() > 0.5) ? -v : v;\r\n        }\r\n        c[0] = this.mXMag * fx;\r\n        c[1] = this.mYMag * fy;\r\n        return c;\r\n    };\r\n\r\n    _nextDampedHarmonic() {\r\n        // computes (Cycles) * cos(  Omega * t )\r\n        let frac = this.mNumCyclesLeft / this.mCycles;\r\n        return frac * frac * Math.cos((1 - frac) * this.mOmega);\r\n    };\r\n}\r\nexport { ShakePosition }","import { vec2 } from \"../Lib/gl-matrix\";\r\nimport { ShakePosition } from \"../Utils/ShakePosition\";\r\n\r\nclass CameraShake {\r\n\r\n    constructor(state, xDelta, yDelta, shakeFrequency, shakeDuration) {\r\n        this.mOrgCenter = vec2.clone(state.getCenter());\r\n        this.mShakeCenter = vec2.clone(this.mOrgCenter);\r\n        this.mShake = new ShakePosition(xDelta, yDelta, shakeFrequency, shakeDuration);\r\n    };\r\n\r\n    updateShakeState() {\r\n        let s = this.mShake.getShakeResults();\r\n        vec2.add(this.mShakeCenter, this.mOrgCenter, s);\r\n    };\r\n\r\n    shakeDone() {\r\n        return this.mShake.shakeDone();\r\n    };\r\n\r\n    getCenter() { return this.mShakeCenter; };\r\n    setRefCenter(c) {\r\n        this.mOrgCenter[0] = c[0];\r\n        this.mOrgCenter[1] = c[1];\r\n    };\r\n}\r\nexport { CameraShake }","\r\nimport { BoundingBox } from \"../Utils/BoundingBox\";\r\nimport { vec2 } from \"../Lib/gl-matrix\";\r\nimport { CameraShake } from \"./CameraShake\";\r\n// Camera.prototype.consolo =function (){\r\n//     console.log(this.mWCCenter );\r\n// }\r\n\r\nexport const CameraManipulation = {\r\n    panWith,\r\n    panTo,\r\n    zoomBy,\r\n    zoomTowards,\r\n    update,\r\n    panBy,\r\n    configInterpolation,\r\n    shake,\r\n}\r\n\r\n// function shake(xDelta, yDelta, shakeFrequency, duration) {\r\n//     this.mCameraShake = new CameraShake(this.mCameraState, xDelta, yDelta, shakeFrequency, duration);\r\n// };\r\nfunction shake(xDelta, yDelta, shakeFrequency, duration) {\r\n    this.mCameraShake = new CameraShake(this.mCameraState, xDelta, yDelta, shakeFrequency, duration);\r\n}\r\n\r\n\r\nfunction update() {\r\n    if (this.mCameraShake !== null) {\r\n        if (this.mCameraShake.shakeDone()) {\r\n            this.mCameraShake = null;\r\n        } else {\r\n            this.mCameraShake.setRefCenter(this.getWCCenter());\r\n            this.mCameraShake.updateShakeState();\r\n        }\r\n    }\r\n    this.mCameraState.updateCameraState();\r\n};\r\n\r\nfunction panBy(dx, dy) {\r\n    let newC = vec2.clone(this.getWCCenter());\r\n    newC[0] += dx;\r\n    newC[1] += dy;\r\n    this.mCameraState.setCenter(newC);\r\n};\r\n\r\nfunction panWith(aXform, zone) {\r\n    let status = this.collideWCBound(aXform, zone);\r\n    if (status !== BoundingBox.eboundCollideStatus.eInside) {\r\n        var pos = aXform.getPosition();\r\n        var newC = this.getWCCenter();\r\n        if ((status & BoundingBox.eboundCollideStatus.eCollideTop) !== 0) {\r\n            newC[1] = pos[1] + (aXform.getHeight() / 2) - (zone * this.getWCHeight() / 2);\r\n        }\r\n        if ((status & BoundingBox.eboundCollideStatus.eCollideBottom) !== 0) {\r\n            newC[1] = pos[1] - (aXform.getHeight() / 2) + (zone * this.getWCHeight() / 2);\r\n        }\r\n        if ((status & BoundingBox.eboundCollideStatus.eCollideRight) !== 0) {\r\n            newC[0] = pos[0] + (aXform.getWidth() / 2) - (zone * this.getWCWidth() / 2);\r\n        }\r\n        if ((status & BoundingBox.eboundCollideStatus.eCollideLeft) !== 0) {\r\n            newC[0] = pos[0] - (aXform.getWidth() / 2) + (zone * this.getWCWidth() / 2);\r\n        }\r\n        this.mCameraState.setCenter(newC);\r\n    }\r\n};\r\n\r\nfunction panTo(cx, cy) {\r\n    this.setWCCenter(cx, cy);\r\n};\r\n\r\n// zoom with respect to the center\r\n// zoom > 1 ==> zooming out, see more of the world\r\n// zoom < 1 ==> zooming in, see less of the world, more detailed\r\n// zoom < 0 is ignored\r\nfunction zoomBy(zoom) {\r\n    if (zoom > 0) {\r\n        this.setWCWidth(this.getWCWidth() * zoom);\r\n    }\r\n};\r\n\r\n// zoom towards (pX, pY) by zoom: \r\n// zoom > 1 ==> zooming out, see more of the world\r\n// zoom < 1 ==> zooming in, see less of the world, more detailed\r\n// zoom < 0 is ignored\r\nfunction zoomTowards(pos, zoom) {\r\n    var delta = [];\r\n    var newC = [];\r\n    vec2.sub(delta, pos, this.getWCCenter());\r\n    vec2.scale(delta, delta, zoom - 1);\r\n    vec2.sub(newC, this.getWCCenter(), delta);\r\n    this.zoomBy(zoom);\r\n    this.mCameraState.setCenter(newC);\r\n};\r\n\r\nfunction configInterpolation(stiffness, duration) {\r\n    this.mCameraState.configInterpolation(stiffness, duration);\r\n};\r\n\r\n","// value: target for interpolation\r\n// cycles: integer, how many cycle it should take for a value to change to final\r\n// rate: the rate at which the value should change at each cycle\r\nclass Interpolate {\r\n    constructor(value, cycles, rate) {\r\n        this.mCurrentValue = value;    // begin value of interpolation\r\n        this.mFinalValue = value;      // final value of interpolation\r\n        this.mCycles = cycles;\r\n        this.mRate = rate;\r\n\r\n        // if there is a new value to interpolate to, number of cycles left for interpolation\r\n        this.mCyclesLeft = 0;\r\n    };\r\n\r\n    getValue() { return this.mCurrentValue; };\r\n    setFinalValue(v) {\r\n        this.mFinalValue = v;\r\n        this.mCyclesLeft = this.mCycles;     // will trigger interpolation\r\n    };\r\n\r\n    updateInterpolation() {\r\n        if (this.mCyclesLeft <= 0) {\r\n            return;\r\n        }\r\n\r\n        this.mCyclesLeft--;\r\n        if (this.mCyclesLeft === 0) {\r\n            this.mCurrentValue = this.mFinalValue;\r\n        } else {\r\n            this._interpolateValue();\r\n        }\r\n    };\r\n\r\n    // stiffness of 1 switches off interpolation\r\n    configInterpolation(stiffness, duration) {\r\n        this.mRate = stiffness;\r\n        this.mCycles = duration;\r\n    };\r\n\r\n    _interpolateValue() {\r\n        this.mCurrentValue = this.mCurrentValue + this.mRate * (this.mFinalValue - this.mCurrentValue);\r\n    };\r\n}\r\nexport { Interpolate };","import { Interpolate } from \"./Interpolate\";\r\nimport { vec2 } from \"../Lib/gl-matrix\";\r\n\r\nclass InterpolateVec2 extends Interpolate {\r\n    constructor(value, cycle, rate) {\r\n        super(value, cycle, rate);\r\n    };\r\n\r\n    // overwrite\r\n    _interpolateValue() {\r\n        vec2.lerp(this.mCurrentValue, this.mCurrentValue, this.mFinalValue, this.mRate);\r\n    };\r\n};\r\n\r\nexport { InterpolateVec2 }","\r\nimport {InterpolateVec2} from \"../Utils/InterpolateVec2\";\r\nimport {Interpolate} from \"../Utils/Interpolate\";\r\n\r\nclass CameraState {\r\n\r\n    constructor(center, width) {\r\n        this.kCycles = 300;  // number of cycles to complete the transition\r\n        this.kRate = 0.1;    // rate of change for each cycle\r\n        this.mCenter = new InterpolateVec2(center, this.kCycles, this.kRate);\r\n        this.mWidth = new Interpolate(width, this.kCycles, this.kRate);\r\n    }\r\n\r\n    getCenter() { return this.mCenter.getValue(); };\r\n    getWidth() { return this.mWidth.getValue(); };\r\n\r\n    setCenter(c) { this.mCenter.setFinalValue(c); };\r\n    setWidth(w) { this.mWidth.setFinalValue(w); };\r\n\r\n    updateCameraState() {\r\n        this.mCenter.updateInterpolation();\r\n        this.mWidth.updateInterpolation();\r\n    };\r\n\r\n    configInterpolation(stiffness, duration) {\r\n        this.mCenter.configInterpolation(stiffness, duration);\r\n        this.mWidth.configInterpolation(stiffness, duration);\r\n    };\r\n}\r\nexport { CameraState };","import { Camera } from \"./Camera\";\r\n\r\nexport const CameraInput = {\r\n    _mouseDCX,\r\n    _mouseDCY,\r\n    isMouseInViewport,\r\n    mouseWCX,\r\n    mouseWCY,\r\n}\r\n\r\nfunction _mouseDCX() {\r\n    \r\n    return this.gEngine.Input.getMousePosX() - this.mViewport[Camera.eViewport.eOrgX];\r\n};\r\n\r\nfunction _mouseDCY() {\r\n    return this.gEngine.Input.getMousePosY() - this.mViewport[Camera.eViewport.eOrgY];\r\n};\r\n\r\nfunction isMouseInViewport() {\r\n    \r\n    let dcX = this._mouseDCX.call(this);\r\n    let dcY = this._mouseDCY.call(this);\r\n    return ((dcX >= 0) && (dcX < this.mViewport[Camera.eViewport.eWidth]) &&\r\n        (dcY >= 0) && (dcY < this.mViewport[Camera.eViewport.eHeight]));\r\n};\r\n\r\nfunction mouseWCX() {\r\n    let minWCX = this.getWCCenter()[0] - this.getWCWidth() / 2;\r\n    return minWCX + (this._mouseDCX() * (this.getWCWidth() / this.mViewport[Camera.eViewport.eWidth]));\r\n};\r\n\r\nfunction mouseWCY() {\r\n    var minWCY = this.getWCCenter()[1] - this.getWCHeight() / 2;\r\n    return minWCY + (this._mouseDCY() * (this.getWCHeight() / this.mViewport[Camera.eViewport.eHeight]));\r\n};","import { Camera } from \"./Camera\";\r\nimport {vec3} from \"../Lib/gl-matrix\";\r\n\r\nexport const CameraXform = {\r\n    fakeZInPixelSpace,\r\n    wcPosToPixel,\r\n    wcSizeToPixel,\r\n}\r\n\r\nfunction fakeZInPixelSpace(z) {\r\n    return z * this.mRenderCache.mWCToPixelRatio;\r\n};\r\n\r\nfunction wcPosToPixel(p) {  // p is a vec3, fake Z\r\n    // Convert the position to pixel space\r\n    let x = this.mViewport[Camera.eViewport.eOrgX] + ((p[0] - this.mRenderCache.mCameraOrgX) * this.mRenderCache.mWCToPixelRatio) + 0.5;\r\n    let y = this.mViewport[Camera.eViewport.eOrgY] + ((p[1] - this.mRenderCache.mCameraOrgY) * this.mRenderCache.mWCToPixelRatio) + 0.5;\r\n    let z = this.fakeZInPixelSpace(p[2]);\r\n    return vec3.fromValues(x, y, z);\r\n};\r\n\r\nfunction wcSizeToPixel(s) {  // \r\n    return (s * this.mRenderCache.mWCToPixelRatio) + 0.5;\r\n};","import { mat4, vec2 } from \"../Lib/gl-matrix\";\r\nimport { BoundingBox } from \"../Utils/BoundingBox\";\r\nimport { CameraManipulation } from \"./Camera_Manipulation\";\r\nimport { CameraState } from \"./CameraState\";\r\nimport { CameraInput } from \"./Camera_Input\";\r\nimport { CameraXform } from \"./Camera_Xform\";\r\n\r\n// Information to be updated once per render for efficiency concerns\r\nclass PerRenderCache {\r\n    constructor() {\r\n        this.mWCToPixelRatio = 1;  // WC to pixel transformation\r\n        this.mCameraOrgX = 1; // Lower-left corner of camera in WC \r\n        this.mCameraOrgY = 1;\r\n    }\r\n};\r\n// wcCenter: is a vec2\r\n// wcWidth: is the width of the user defined WC\r\n//      Height of the user defined WC is implicitly defined by the viewport aspect ratio\r\n//      Please refer to the following\r\n// viewportRect: an array of 4 elements\r\n//      [0] [1]: (x,y) position of lower left corner on the canvas (in pixel)\r\n//      [2]: width of viewport\r\n//      [3]: height of viewport\r\n//      \r\n//  wcHeight = wcWidth * viewport[3]/viewport[2]\r\n//\r\nclass Camera {\r\n\r\n    static eViewport = {\r\n        eOrgX: 0,\r\n        eOrgY: 1,\r\n        eWidth: 2,\r\n        eHeight: 3\r\n    };\r\n\r\n    constructor(gEngine, wcCenter, wcWidth, viewportArray, bound) {\r\n        // WC and viewport position and size\r\n        this.gl = gEngine.Core.getGL();\r\n        this.gEngine = gEngine;\r\n        // WC and viewport position and size\r\n        this.mCameraState = new CameraState(wcCenter, wcWidth);\r\n        this.mCameraShake = null;\r\n\r\n        this.mViewport = [];  // [x, y, width, height]\r\n        this.mViewportBound = 0;\r\n        if (bound !== undefined) {\r\n            this.mViewportBound = bound;\r\n        }\r\n        this.mScissorBound = [];  // use for bounds\r\n        this.setViewport(viewportArray, this.mViewportBound);\r\n\r\n        this.mNearPlane = 0;\r\n        this.mFarPlane = 1000;\r\n\r\n        // transformation matrices\r\n        this.mViewMatrix = mat4.create();\r\n        this.mProjMatrix = mat4.create();\r\n        this.mVPMatrix = mat4.create();\r\n\r\n\r\n        // background color\r\n        this.mBgColor = [0.8, 0.8, 0.8, 1]; // RGB and Alpha\r\n\r\n        // per-rendering cached information\r\n        // needed for computing transforms for shaders\r\n        // updated each time in SetupViewProjection()\r\n        this.mRenderCache = new PerRenderCache();\r\n        // SHOULD NOT be used except \r\n        // xform operations during the rendering\r\n        // Client game should not access this!\r\n\r\n        Object.assign(this, { ...CameraManipulation, ...CameraInput, ...CameraXform }); //对Camera类进行扩展\r\n\r\n    }\r\n\r\n    setWCCenter(xPos, yPos) {\r\n        let p = vec2.fromValues(xPos, yPos);\r\n        this.mCameraState.setCenter(p);\r\n    };\r\n    getWCCenter() { return this.mCameraState.getCenter(); };\r\n    setWCWidth(width) { this.mCameraState.setWidth(width); };\r\n    getWCWidth() { return this.mCameraState.getWidth(); };\r\n    getWCHeight() { return this.mCameraState.getWidth() * this.mViewport[Camera.eViewport.eHeight] / this.mViewport[Camera.eViewport.eWidth]; };\r\n\r\n    setViewport(viewportArray, bound) {\r\n        if (bound === undefined) {\r\n            bound = this.mViewportBound;\r\n        }\r\n        // [x, y, width, height]\r\n        this.mViewport[0] = viewportArray[0] + bound;\r\n        this.mViewport[1] = viewportArray[1] + bound;\r\n        this.mViewport[2] = viewportArray[2] - (2 * bound);\r\n        this.mViewport[3] = viewportArray[3] - (2 * bound);\r\n        this.mScissorBound[0] = viewportArray[0];\r\n        this.mScissorBound[1] = viewportArray[1];\r\n        this.mScissorBound[2] = viewportArray[2];\r\n        this.mScissorBound[3] = viewportArray[3];\r\n    };\r\n    getViewport() {\r\n        let out = [];\r\n        out[0] = this.mScissorBound[0];\r\n        out[1] = this.mScissorBound[1];\r\n        out[2] = this.mScissorBound[2];\r\n        out[3] = this.mScissorBound[3];\r\n        return out;\r\n    };\r\n\r\n    setBackgroundColor(newColor) { this.mBgColor = newColor; };\r\n    getBackgroundColor() { return this.mBgColor; };\r\n\r\n    // Getter for the View-Projection transform operator\r\n    getVPMatrix() {\r\n        return this.mVPMatrix;\r\n    };\r\n\r\n    setupViewProjection() {\r\n        // Step A1: Set up the viewport: area on canvas to be drawn\r\n        this.gl.viewport(\r\n            this.mViewport[0],  // x position of bottom-left corner of the area to be drawn\r\n            this.mViewport[1],  // y position of bottom-left corner of the area to be drawn\r\n            this.mViewport[2],  // width of the area to be drawn\r\n            this.mViewport[3]); // height of the area to be drawn\r\n        // Step A2: set up the corresponding scissor area to limit the clear area\r\n        this.gl.scissor(\r\n            this.mScissorBound[0], // x position of bottom-left corner of the area to be drawn\r\n            this.mScissorBound[1], // y position of bottom-left corner of the area to be drawn\r\n            this.mScissorBound[2], // width of the area to be drawn\r\n            this.mScissorBound[3]);// height of the area to be drawn\r\n        // Step A3: set the color to be clear\r\n        this.gl.clearColor(this.mBgColor[0], this.mBgColor[1], this.mBgColor[2], this.mBgColor[3]);  // set the color to be cleared\r\n        // Step A4: enable the scissor area, clear, and then disable the scissor area\r\n        this.gl.enable(this.gl.SCISSOR_TEST);\r\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\r\n        this.gl.disable(this.gl.SCISSOR_TEST);\r\n\r\n        // Step B1: define the view matrix\r\n        let center = [];\r\n        if (this.mCameraShake !== null) {\r\n            center = this.mCameraShake.getCenter();\r\n        } else {\r\n            center = this.getWCCenter();\r\n        };\r\n        mat4.lookAt(this.mViewMatrix,\r\n            [center[0], center[1], 10],   // WC center\r\n            [center[0], center[1], 0],    // \r\n            [0, 1, 0]);     // orientation\r\n        // Step B2: define the projection matrix\r\n        let halfWCWidth = 0.5 * this.getWCWidth();\r\n        let halfWCHeight = halfWCWidth * this.mViewport[3] / this.mViewport[2]; // viewportH/viewportW\r\n        mat4.ortho(this.mProjMatrix,\r\n            -halfWCWidth,   // distance to left of WC\r\n            halfWCWidth,   // distance to right of WC\r\n            -halfWCHeight,  // distance to bottom of WC\r\n            halfWCHeight,  // distance to top of WC\r\n            this.mNearPlane,   // z-distance to near plane \r\n            this.mFarPlane  // z-distance to far plane \r\n        );\r\n\r\n        // Step B3: concatenate view and project matrices\r\n        mat4.multiply(this.mVPMatrix, this.mProjMatrix, this.mViewMatrix);\r\n\r\n        // Step B4: compute and cache per-rendering information\r\n        this.mRenderCache.mWCToPixelRatio = this.mViewport[Camera.eViewport.eWidth] / this.getWCWidth();\r\n        this.mRenderCache.mCameraOrgX = center[0] - (this.getWCWidth() / 2);\r\n        this.mRenderCache.mCameraOrgY = center[1] - (this.getWCHeight() / 2);\r\n    }\r\n\r\n    collideWCBound(aXform, zone) {\r\n        let bbox = new BoundingBox(aXform.getPosition(), aXform.getWidth(), aXform.getHeight());\r\n        let w = zone * this.getWCWidth();\r\n        let h = zone * this.getWCHeight();\r\n        let cameraBound = new BoundingBox(this.getWCCenter(), w, h);\r\n        return cameraBound.boundCollideStatus(bbox);\r\n    };\r\n\r\n    clampAtBoundary(aXform, zone) {\r\n        var status = this.collideWCBound(aXform, zone);\r\n        if (status !== BoundingBox.eboundCollideStatus.eInside) {\r\n            var pos = aXform.getPosition();\r\n            if ((status & BoundingBox.eboundCollideStatus.eCollideTop) !== 0) {\r\n                pos[1] = (this.getWCCenter())[1] + (zone * this.getWCHeight() / 2) - (aXform.getHeight() / 2);\r\n            }\r\n            if ((status & BoundingBox.eboundCollideStatus.eCollideBottom) !== 0) {\r\n                pos[1] = (this.getWCCenter())[1] - (zone * this.getWCHeight() / 2) + (aXform.getHeight() / 2);\r\n            }\r\n            if ((status & BoundingBox.eboundCollideStatus.eCollideRight) !== 0) {\r\n                pos[0] = (this.getWCCenter())[0] + (zone * this.getWCWidth() / 2) - (aXform.getWidth() / 2);\r\n            }\r\n            if ((status & BoundingBox.eboundCollideStatus.eCollideLeft) !== 0) {\r\n                pos[0] = (this.getWCCenter())[0] - (zone * this.getWCWidth() / 2) + (aXform.getWidth() / 2);\r\n            }\r\n        }\r\n        return status;\r\n    };\r\n}\r\n\r\n\r\n\r\nexport { Camera }","import { vec2, vec3, vec4, mat4 } from \"../Lib/gl-matrix\";\r\n\r\nclass Transform {\r\n    constructor() {\r\n        this.mPosition = vec2.fromValues(0, 0);\r\n        this.mScale = vec2.fromValues(1, 1);\r\n        this.mRotationInRad = 0.0;\r\n    }\r\n\r\n    // 设置位置\r\n    getXPos() { return this.mPosition[0]; };\r\n    setXPos(xPos) { this.mPosition[0] = xPos; };\r\n    getYPos() { return this.mPosition[1]; };\r\n    setYPos(yPos) { this.mPosition[1] = yPos; };\r\n    setPosition(xPos, yPos) {\r\n        this.setXPos(xPos);\r\n        this.setYPos(yPos);\r\n    }\r\n    getPosition() { return this.mPosition; };\r\n    incXPosBy(delta) { this.mPosition[0] += delta; };\r\n    incYPosBy(delta) { this.mPosition[1] += delta; };\r\n\r\n    // 大小\r\n    getWidth() { return this.mScale[0]; };\r\n    setWidth(width) { this.mScale[0] = width; };\r\n    incWidthBy(delta) { this.mScale[0] += delta; };\r\n    getHeight() { return this.mScale[1]; };\r\n    setHeight(height) { this.mScale[1] = height; };\r\n    incHeightBy(delta) { this.mScale[1] += delta; };\r\n    setSize(width, height) {\r\n        this.setWidth(width);\r\n        this.setHeight(height);\r\n    };\r\n    getSize() { return this.mScale; };\r\n    incSizeBy(delta) {\r\n        this.incWidthBy(delta);\r\n        this.incHeightBy(delta);\r\n    };\r\n\r\n    //旋转\r\n    setRotationInRad(rotationInRadians) {\r\n        this.mRotationInRad = rotationInRadians;\r\n        while (this.mRotationInRad > (2 * Math.PI)) {\r\n            this.mRotationInRad -= (2 * Math.PI);\r\n        }\r\n    };\r\n    setRotationInDegree(rotationInDegree) {\r\n        this.setRotationInRad(rotationInDegree * Math.PI / 180.0);\r\n    };\r\n    incRotationByDegree(deltaDegree) {\r\n        this.incRotationByRad(deltaDegree * Math.PI / 180.0);\r\n    };\r\n    incRotationByRad(deltaRad) {\r\n        this.setRotationInRad(this.mRotationInRad + deltaRad);\r\n    };\r\n    getRotationInRad() { return this.mRotationInRad; };\r\n    getRotationInDegree() { return this.mRotationInRad * 180.0 / Math.PI; };\r\n\r\n    getXform() {\r\n        // Creates a blank identity matrix\r\n        var matrix = mat4.create();\r\n    \r\n        // The matrices that WebGL uses are transposed, thus the typical matrix\r\n        // operations must be in reverse.\r\n    \r\n        // Step A: compute translation, for now z is always at 0.0\r\n        mat4.translate(matrix, matrix, vec3.fromValues(this.getXPos(), this.getYPos(), 0.0));\r\n        // Step B: concatenate with rotation.\r\n        mat4.rotateZ(matrix, matrix, this.getRotationInRad());\r\n        // Step C: concatenate with scaling\r\n        mat4.scale(matrix, matrix, vec3.fromValues(this.getWidth(), this.getHeight(), 1.0));\r\n    \r\n        return matrix;\r\n    };\r\n   \r\n}\r\n\r\nexport { Transform }","import { Transform } from \"../Utils/Transform\";\r\n\r\nclass Renderable {\r\n    constructor(gEnigne) {\r\n        \r\n        this.gEnigne = gEnigne;\r\n        console.log(\"Renderable::constructor:-- \" + this.gEnigne.DefaultResources.getConstColorShader());\r\n        this.mShader = this.gEnigne.DefaultResources.getConstColorShader();\r\n        console.log(\"Renderable::constructor: \" + this.mShader);\r\n        this.mColor = [1, 1, 1, 1]\r\n        this.mXform = new Transform();\r\n        this.gl = this.gEnigne.Core.getGL();\r\n    };\r\n\r\n    draw(aCamera) {\r\n        \r\n        this.mShader.activateShader(this.mColor, aCamera);\r\n        this.mShader.loadObjectTransform(this.mXform.getXform());\r\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\r\n    };\r\n\r\n    setColor(color) {\r\n        this.mColor = color;\r\n    };\r\n\r\n    getColor() {\r\n        return this.mColor;\r\n    };\r\n\r\n    getXform() {\r\n        return this.mXform;\r\n    }\r\n\r\n    _setShader(s) { this.mShader = s; };\r\n}\r\n\r\nexport { Renderable }","import { Renderable } from \"./Renderable\";\r\nimport { vec2 } from \"../Lib/gl-matrix\";\r\n\r\nclass TextureRenderable extends Renderable {\r\n    constructor(gEngine, myTexture) {\r\n        super(gEngine);\r\n        this.gEngine = gEngine;\r\n        super.setColor([1, 1, 1, 0]);\r\n        super._setShader(this.gEngine.DefaultResources.getTextureShader());\r\n\r\n        this.mTexture = myTexture;          // texture for this object, cannot be a \"null\"\r\n        // these two instance variables are to cache texture information\r\n        // for supporting per-pixel accurate collision\r\n        this.mTextureInfo = null;\r\n        this.mColorArray = null;\r\n        // defined for subclass to override\r\n        this.mTexWidth = 0;\r\n        this.mTexHeight = 0;\r\n        this.mTexLeftIndex = 0;\r\n        this.mTexBottomIndex = 0;\r\n\r\n        this.setTexture(myTexture);     // texture for this object, cannot be a \"null\"\r\n\r\n    };\r\n\r\n    draw(aCamera) {\r\n        // activate the texture\r\n\r\n        this.gEngine.Textures.activateTexture(this.mTexture);\r\n        super.draw(aCamera);\r\n    };\r\n\r\n    getTexture() { return this.mTexture; };\r\n    setTexture(newTexture) {\r\n        this.mTexture = newTexture;\r\n        // these two instance variables are to cache texture information\r\n        // for supporting per-pixel accurate collision\r\n        this.mTextureInfo = this.gEngine.Textures.getTextureInfo(newTexture);\r\n        this.mColorArray = null;\r\n        // defined for subclass to override\r\n        this.mTexWidth = this.mTextureInfo.mWidth;\r\n        this.mTexHeight = this.mTextureInfo.mHeight;\r\n        this.mTexLeftIndex = 0;\r\n        this.mTexBottomIndex = 0;\r\n    };\r\n\r\n    pixelTouches(other, wcTouchPos) {\r\n        var pixelTouch = false;\r\n        var xIndex = 0, yIndex;\r\n        var otherIndex = [0, 0];\r\n\r\n        var xDir = [1, 0];\r\n        var yDir = [0, 1];\r\n        var otherXDir = [1, 0];\r\n        var otherYDir = [0, 1];\r\n        //这个需要检测因为新版本增加了rotate 所以自我添加了rotateA;\r\n        vec2.rotateA(xDir, xDir, this.mXform.getRotationInRad());\r\n        vec2.rotateA(yDir, yDir, this.mXform.getRotationInRad());\r\n        vec2.rotateA(otherXDir, otherXDir, other.mXform.getRotationInRad());\r\n        vec2.rotateA(otherYDir, otherYDir, other.mXform.getRotationInRad());\r\n\r\n        while ((!pixelTouch) && (xIndex < this.mTexWidth)) {\r\n            yIndex = 0;\r\n            while ((!pixelTouch) && (yIndex < this.mTexHeight)) {\r\n                if (this._pixelAlphaValue(xIndex, yIndex) > 0) {\r\n                    this._indexToWCPosition(wcTouchPos, xIndex, yIndex, xDir, yDir);\r\n                    other._wcPositionToIndex(otherIndex, wcTouchPos, otherXDir, otherYDir);\r\n                    if ((otherIndex[0] >= 0) && (otherIndex[0] < other.mTexWidth) &&\r\n                        (otherIndex[1] >= 0) && (otherIndex[1] < other.mTexHeight)) {\r\n                        pixelTouch = other._pixelAlphaValue(otherIndex[0], otherIndex[1]) > 0;\r\n                    }\r\n                }\r\n                yIndex++;\r\n            }\r\n            xIndex++;\r\n        }\r\n        return pixelTouch;\r\n    };\r\n\r\n    setColorArray() {\r\n        if (this.mColorArray === null) {\r\n            this.mColorArray = this.gEngine.Textures.getColorArray(this.mTexture);\r\n        }\r\n    };\r\n\r\n    _pixelAlphaValue(x, y) {\r\n        y += this.mTexBottomIndex;\r\n        x += this.mTexLeftIndex;\r\n        x = x * 4;\r\n        y = y * 4;\r\n        return this.mColorArray[(y * this.mTextureInfo.mWidth) + x + 3];\r\n    };\r\n\r\n    _wcPositionToIndex(returnIndex, wcPos, xDir, yDir) {\r\n        // use wcPos to compute the corresponding returnIndex[0 and 1]\r\n        let delta = [];\r\n        vec2.sub(delta, wcPos, this.mXform.getPosition());\r\n        let xDisp = vec2.dot(delta, xDir);\r\n        let yDisp = vec2.dot(delta, yDir);\r\n        returnIndex[0] = this.mTexWidth * (xDisp / this.mXform.getWidth());\r\n        returnIndex[1] = this.mTexHeight * (yDisp / this.mXform.getHeight());\r\n\r\n        // recall that xForm.getPosition() returns center, yet\r\n        // Texture origin is at lower-left corner!\r\n        returnIndex[0] += this.mTexWidth / 2;\r\n        returnIndex[1] += this.mTexHeight / 2;\r\n\r\n        returnIndex[0] = Math.floor(returnIndex[0]);\r\n        returnIndex[1] = Math.floor(returnIndex[1]);\r\n    };\r\n\r\n    _indexToWCPosition(returnWCPos, i, j, xDir, yDir) {\r\n        //console.log(\"TextureRenderable::_indexToWCPosition\")\r\n        var x = i * this.mXform.getWidth() / this.mTexWidth;\r\n        var y = j * this.mXform.getHeight() / this.mTexHeight;\r\n        var xDisp = x - (this.mXform.getWidth() * 0.5);\r\n        var yDisp = y - (this.mXform.getHeight() * 0.5);\r\n        var xDirDisp = [];\r\n        var yDirDisp = [];\r\n\r\n        vec2.scale(xDirDisp, xDir, xDisp);\r\n        vec2.scale(yDirDisp, yDir, yDisp);\r\n        vec2.add(returnWCPos, this.mXform.getPosition(), xDirDisp);\r\n        vec2.add(returnWCPos, returnWCPos, yDirDisp);\r\n\r\n    };\r\n};\r\n\r\nexport { TextureRenderable }","import { TextureRenderable } from \"./TextureRenderable\";\r\nimport { Renderable } from \"./Renderable\";\r\n\r\nclass SpriteRenderable extends TextureRenderable {\r\n    //// the expected texture coordinate array is an array of 8 floats where elements:\r\n    //  [0] [1]: is u/v coordinate of Top-Right \r\n    //  [2] [3]: is u/v coordinate of Top-Left\r\n    //  [4] [5]: is u/v coordinate of Bottom-Right\r\n    //  [6] [7]: is u/v coordinate of Bottom-Left\r\n    // Convention: eName is an enumerated data type\r\n    static eTexCoordArray = {\r\n        eLeft: 2,\r\n        eRight: 0,\r\n        eTop: 1,\r\n        eBottom: 5\r\n    };\r\n    // 为什么会是这样的数字是因\r\n    // The 8 elements:\r\n    //      mTexRight, mTexTop         // x,y of top-right\r\n    //      mTexLeft,   mTexTop,\r\n    //      mTexRight,  mTexBottom,\r\n    //      mTexLeft,   mTexBottom\r\n    // UV坐标系很容易知道 0 是 mTexRight 所以eRight为0\r\n    // 其余数同理mTexBottom是数组中5 eBootom也为5\r\n\r\n    constructor(gEnigne, myTexture) {\r\n        super(gEnigne, myTexture);\r\n        this.gEnigne = gEnigne;\r\n        // 调用祖父类方法可参考 祖父类函数调用方法\r\n        Renderable.prototype._setShader.call(this, this.gEnigne.DefaultResources.getSpriteShader());\r\n        this.mTexLeft = 0.0;   // bounds of texture coordinate (0 is left, 1 is right)\r\n        this.mTexRight = 1.0;  // \r\n        this.mTexTop = 1.0;    //   1 is top and 0 is bottom of image\r\n        this.mTexBottom = 0.0; // \r\n        this._setTexInfo();\r\n        console.log(\"SpriteRenderable::constructor: \");\r\n    }\r\n\r\n    // specify element region by texture coordinate (between 0 to 1)\r\n    setElementUVCoordinate(left, right, bottom, top) {\r\n        this.mTexLeft = left;\r\n        this.mTexRight = right;\r\n        this.mTexBottom = bottom;\r\n        this.mTexTop = top;\r\n        this._setTexInfo();\r\n    };\r\n\r\n    // specify element region by pixel positions (between 0 to image resolutions)\r\n    setElementPixelPositions(left, right, bottom, top) {\r\n        var texInfo = this.gEnigne.ResourceMap.retrieveAsset(this.mTexture);\r\n        // entire image width, height\r\n        var imageW = texInfo.mWidth;\r\n        var imageH = texInfo.mHeight;\r\n\r\n        this.mTexLeft = left / imageW;\r\n        this.mTexRight = right / imageW;\r\n        this.mTexBottom = bottom / imageH;\r\n        this.mTexTop = top / imageH;\r\n        this._setTexInfo();\r\n    };\r\n\r\n    getElementUVCoordinateArray() {\r\n        return [\r\n            this.mTexRight, this.mTexTop,          // x,y of top-right\r\n            this.mTexLeft, this.mTexTop,\r\n            this.mTexRight, this.mTexBottom,\r\n            this.mTexLeft, this.mTexBottom\r\n        ];\r\n    };\r\n\r\n    draw(aCamera) {\r\n        // set the current texture coordinate\r\n        // \r\n        // activate the texture\r\n\r\n        //console.log(\"SpriteRenderable::draw()\");\r\n        this.mShader.setTextureCoordinate(this.getElementUVCoordinateArray());\r\n        super.draw(aCamera);\r\n    };\r\n\r\n    _setTexInfo() {\r\n        var imageW = this.mTextureInfo.mWidth;\r\n        var imageH = this.mTextureInfo.mHeight;\r\n\r\n        this.mTexLeftIndex = this.mTexLeft * imageW;\r\n        this.mTexBottomIndex = this.mTexBottom * imageH;\r\n\r\n        this.mTexWidth = ((this.mTexRight - this.mTexLeft) * imageW) + 1;\r\n        this.mTexHeight = ((this.mTexTop - this.mTexBottom) * imageH) + 1;\r\n    };\r\n}\r\n\r\nexport { SpriteRenderable }","import { Transform } from \"../Utils/Transform\";\r\nimport { SpriteRenderable } from \"./SpriteRenderable\";\r\n\r\nclass FontRenderable {\r\n    constructor(gEngine, aString) {\r\n        this.gEngine = gEngine;\r\n        this.mFont = this.gEngine.DefaultResources.getDefaultFont();\r\n        this.mOneChar = new SpriteRenderable(this.gEngine, this.mFont + \".png\");\r\n        this.mXform = new Transform(); // transform that moves this object around\r\n        this.mText = aString;\r\n    }\r\n\r\n    draw(aCamera) {\r\n        // we will draw the text string by calling to mOneChar for each of the\r\n        // chars in the mText string.\r\n        var widthOfOneChar = this.mXform.getWidth() / this.mText.length;\r\n        var heightOfOneChar = this.mXform.getHeight();\r\n        // this.mOneChar.getXform().SetRotationInRad(this.mXform.getRotationInRad());\r\n        var yPos = this.mXform.getYPos();\r\n\r\n        // center position of the first char\r\n        var xPos = this.mXform.getXPos() - (widthOfOneChar / 2) + (widthOfOneChar * 0.5);\r\n        var charIndex, aChar, charInfo, xSize, ySize, xOffset, yOffset;\r\n        for (charIndex = 0; charIndex < this.mText.length; charIndex++) {\r\n            aChar = this.mText.charCodeAt(charIndex);\r\n            charInfo = this.gEngine.Fonts.getCharInfo(this.mFont, aChar);\r\n\r\n            // set the texture coordinate\r\n            this.mOneChar.setElementUVCoordinate(charInfo.mTexCoordLeft, charInfo.mTexCoordRight,\r\n                charInfo.mTexCoordBottom, charInfo.mTexCoordTop);\r\n\r\n            // now the size of the char\r\n            xSize = widthOfOneChar * charInfo.mCharWidth;\r\n            ySize = heightOfOneChar * charInfo.mCharHeight;\r\n            this.mOneChar.getXform().setSize(xSize, ySize);\r\n\r\n            // how much to offset from the center\r\n            xOffset = widthOfOneChar * charInfo.mCharWidthOffset * 0.5;\r\n            yOffset = heightOfOneChar * charInfo.mCharHeightOffset * 0.5;\r\n\r\n            this.mOneChar.getXform().setPosition(xPos - xOffset, yPos - yOffset);\r\n\r\n            this.mOneChar.draw(aCamera);\r\n\r\n            xPos += widthOfOneChar;\r\n        }\r\n        //console.log(\"FontRenderable::draw: \"+xPos);\r\n    };\r\n\r\n    getXform() { return this.mXform; };\r\n    getText() { return this.mText; };\r\n\r\n    setText(t) {\r\n        this.mText = t;\r\n        this.setTextHeight(this.getXform().getHeight());\r\n    };\r\n\r\n    setTextHeight(h) {\r\n        var charInfo = this.gEngine.Fonts.getCharInfo(this.mFont, \"A\".charCodeAt(0)); // this is for \"A\"\r\n        var w = h * charInfo.mCharAspectRatio;\r\n        this.getXform().setSize(w * this.mText.length, h);\r\n    };\r\n\r\n    getFont() { return this.mFont; };\r\n    setFont(f) {\r\n        this.mFont = f;\r\n        this.mOneChar.setTexture(this.mFont + \".png\");\r\n    };\r\n\r\n    setColor(c) { this.mOneChar.setColor(c); };\r\n    getColor() { return this.mOneChar.getColor(); };\r\n\r\n    update() { };\r\n\r\n    getStringWidth(h) {\r\n        var stringWidth = 0;\r\n        var charSize = h;\r\n        var charIndex, aChar, charInfo;\r\n        for (charIndex = 0; charIndex < this.mText.length; charIndex++) {\r\n            aChar = this.mText.charCodeAt(charIndex);\r\n            charInfo = this.gEngine.Fonts.getCharInfo(this.mFont, aChar);\r\n            console.log(\"FontRenderable::getStringWidth:\");\r\n            stringWidth += charSize * charInfo.mCharWidth * charInfo.mXAdvance;\r\n        }\r\n        return stringWidth;\r\n    };\r\n}\r\n\r\nexport { FontRenderable }","import { vec2, vec3 } from \"../Lib/gl-matrix\";\r\nimport { BoundingBox } from \"../Utils/BoundingBox\";\r\n\r\nclass GameObject {\r\n    constructor() {\r\n        this.mRenderComponent = null;\r\n        this.mVisible = true;\r\n        this.mCurrentFrontDir = vec2.fromValues(0, 1);  // this is the current front direction of the object\r\n        this.mSpeed = 0;\r\n    };\r\n\r\n\r\n    getXform() { return this.mRenderComponent.getXform(); };\r\n    getBBox() {\r\n        let xform = this.getXform();\r\n        let b = new BoundingBox(xform.getPosition(), xform.getWidth(), xform.getHeight());\r\n        return b;\r\n    };\r\n    setVisibility(f) { this.mVisible = f; };\r\n    isVisible() { return this.mVisible; };\r\n\r\n    setSpeed(s) { this.mSpeed = s; };\r\n    getSpeed() { return this.mSpeed; };\r\n    incSpeedBy(delta) { this.mSpeed += delta; };\r\n    setCurrentFrontDir(f) { vec2.normalize(this.mCurrentFrontDir, f); };\r\n    getCurrentFrontDir() { return this.mCurrentFrontDir; };\r\n\r\n    rotateObjPointTo(p, rate) {\r\n        // Step A: determine if reach the destination position p\r\n        let dir = [];\r\n        vec2.sub(dir, p, this.getXform().getPosition());\r\n        let len = vec2.length(dir);\r\n        if (len < Number.MIN_VALUE) {\r\n            return; // we are there.\r\n        }\r\n        vec2.scale(dir, dir, 1 / len);\r\n\r\n        // Step B: compute the angle to rotate\r\n        let fdir = this.getCurrentFrontDir();\r\n        let cosTheta = vec2.dot(dir, fdir);\r\n\r\n        if (cosTheta > 0.999999) { // almost exactly the same direction\r\n            return;\r\n        }\r\n\r\n        // Step C: clamp the cosTheda to -1 to 1 \r\n        // in a perfect world, this would never happen! BUT ...\r\n        if (cosTheta > 1) {\r\n            cosTheta = 1;\r\n        } else {\r\n            if (cosTheta < -1) {\r\n                cosTheta = -1;\r\n            }\r\n        }\r\n\r\n        // Step D: compute whether to rotate clockwise, or counterclockwise\r\n        let dir3d = vec3.fromValues(dir[0], dir[1], 0);\r\n        let f3d = vec3.fromValues(fdir[0], fdir[1], 0);\r\n        let r3d = [];\r\n        vec3.cross(r3d, f3d, dir3d);\r\n\r\n        let rad = Math.acos(cosTheta);  // radian to roate\r\n        if (r3d[2] < 0) {\r\n            rad = -rad;\r\n        }\r\n\r\n        // Step E: rotate the facing direction with the angle and rate\r\n        rad *= rate;  // actual angle need to rotate from Obj's front\r\n        vec2.rotateA(this.getCurrentFrontDir(), this.getCurrentFrontDir(), rad);\r\n        this.getXform().incRotationByRad(rad);\r\n    };\r\n\r\n    update() {\r\n        // simple default behavior\r\n        let pos = this.getXform().getPosition();\r\n        vec2.scaleAndAdd(pos, pos, this.getCurrentFrontDir(), this.getSpeed());\r\n\r\n    };\r\n\r\n    getRenderable() { return this.mRenderComponent; };\r\n\r\n    setRenderable(renderableObj) { this.mRenderComponent = renderableObj; };\r\n\r\n    draw(aCamera) {\r\n        if (this.isVisible()) {\r\n            this.mRenderComponent.draw(aCamera);\r\n        }\r\n    };\r\n\r\n    pixelTouches(otherObj, wcTouchPos) {\r\n        // only continue if both objects have getColorArray defined \r\n        // if defined, should have other texture intersection support!\r\n        var pixelTouch = false;\r\n        var myRen = this.getRenderable();\r\n        var otherRen = otherObj.getRenderable();\r\n\r\n        if ((typeof myRen.pixelTouches === \"function\") && (typeof otherRen.pixelTouches === \"function\")) {\r\n            if ((myRen.getXform().getRotationInRad() === 0) && (otherRen.getXform().getRotationInRad() === 0)) {\r\n                // no rotation, we can use bbox ...\r\n                var otherBbox = otherObj.getBBox();\r\n                if (otherBbox.intersectsBound(this.getBBox())) {\r\n                    myRen.setColorArray();\r\n                    otherRen.setColorArray();\r\n                    pixelTouch = myRen.pixelTouches(otherRen, wcTouchPos);\r\n                }\r\n            } else {\r\n                // One or both are rotated, compute an encompassing circle\r\n                // by using the hypotenuse as radius\r\n                var mySize = myRen.getXform().getSize();\r\n                var otherSize = otherRen.getXform().getSize();\r\n                var myR = Math.sqrt(0.5 * mySize[0] * 0.5 * mySize[0] + 0.5 * mySize[1] * 0.5 * mySize[1]);\r\n                var otherR = Math.sqrt(0.5 * otherSize[0] * 0.5 * otherSize[0] + 0.5 * otherSize[1] * 0.5 * otherSize[1]);\r\n                var d = [];\r\n                vec2.sub(d, myRen.getXform().getPosition(), otherRen.getXform().getPosition());\r\n                if (vec2.length(d) < (myR + otherR)) {\r\n                    myRen.setColorArray();\r\n                    otherRen.setColorArray();\r\n                    pixelTouch = myRen.pixelTouches(otherRen, wcTouchPos);\r\n                }\r\n            }\r\n        }\r\n        return pixelTouch;\r\n    };\r\n}\r\nexport { GameObject }","import { SpriteRenderable } from \"./SpriteRenderable\";\r\nimport { Renderable } from \"./Renderable\";\r\n\r\nclass SpriteAnimateRenderable extends SpriteRenderable {\r\n    // Assumption is that the first sprite in an animation is always the left-most element.\r\n    static eAnimationType = {\r\n        eAnimateRight: 0,     // Animate from first (left) towards right, when hit the end, start from the left again\r\n        eAnimateLeft: 1,      // Compute find the last element (in the right), start from the right animate left-wards, \r\n        eAnimateSwing: 2      // Animate from first (left) towards the right, when hit the end, animates backwards \r\n    }\r\n\r\n    constructor(gEngine, myTexture) {\r\n        super(gEngine, myTexture);\r\n        this.gEngine = gEngine;\r\n        super._setShader.call(this, gEngine.DefaultResources.getSpriteShader());\r\n\r\n        // All coordinates are in texture coordinate (UV between 0 to 1)\r\n\r\n        // Information on the sprite element\r\n        this.mFirstElmLeft = 0.0; // 0.0 is left corner of image\r\n        this.mElmTop = 1.0;  // 1.0 is top corner of image\r\n        this.mElmWidth = 1.0;     // default sprite element size is the entire image\r\n        this.mElmHeight = 1.0;\r\n        this.mWidthPadding = 0.0;\r\n        this.mNumElems = 1;   // number of elements in an animation\r\n\r\n        //\r\n        // per animation settings\r\n        this.mUpdateInterval = 1;   // how often to advance\r\n        this.mAnimationType = SpriteAnimateRenderable.eAnimationType.eAnimateRight;\r\n\r\n        this.mCurrentAnimAdvance = -1;\r\n        this.mCurrentElm = 0;\r\n        this._initAnimation();\r\n    }\r\n\r\n    _initAnimation() {\r\n        // Currently running animation\r\n        this.mCurrentTick = 0;\r\n        switch (this.mAnimationType) {\r\n            case SpriteAnimateRenderable.eAnimationType.eAnimateRight:\r\n                this.mCurrentElm = 0;\r\n                this.mCurrentAnimAdvance = 1; // either 1 or -1\r\n                break;\r\n            case SpriteAnimateRenderable.eAnimationType.eAnimateSwing:\r\n                this.mCurrentAnimAdvance = -1 * this.mCurrentAnimAdvance; // swings ... \r\n                //console.log(\"Before SpriteAnimateRenderable::swing: \"+this.mCurrentElm);\r\n                this.mCurrentElm += 2 * this.mCurrentAnimAdvance; //置位\r\n                //console.log(\"SpriteAnimateRenderable::swing: \"+this.mCurrentElm);\r\n                break;\r\n            case SpriteAnimateRenderable.eAnimationType.eAnimateLeft:\r\n                this.mCurrentElm = this.mNumElems - 1;\r\n                this.mCurrentAnimAdvance = -1; // either 1 or -1\r\n                break;\r\n        }\r\n        this._setSpriteElement();\r\n    };\r\n\r\n    _setSpriteElement() {\r\n        var left = this.mFirstElmLeft + (this.mCurrentElm * (this.mElmWidth + this.mWidthPadding));\r\n        super.setElementUVCoordinate.call(this, left, left + this.mElmWidth,\r\n            this.mElmTop - this.mElmHeight, this.mElmTop);\r\n    };\r\n\r\n    // Always set the left-most element to be the first\r\n    setSpriteSequence(\r\n        topPixel,   // offset from top-left\r\n        leftPixel, // offset from top-left\r\n        elmWidthInPixel,\r\n        elmHeightInPixel,\r\n        numElements,      // number of elements in sequence\r\n        wPaddingInPixel  // left/right padding\r\n    ) {\r\n        var texInfo = this.gEngine.ResourceMap.retrieveAsset(this.mTexture);\r\n        // entire image width, height\r\n        var imageW = texInfo.mWidth;\r\n        var imageH = texInfo.mHeight;\r\n\r\n        this.mNumElems = numElements;   // number of elements in animation\r\n        this.mFirstElmLeft = leftPixel / imageW;\r\n        this.mElmTop = topPixel / imageH;\r\n        this.mElmWidth = elmWidthInPixel / imageW;\r\n        this.mElmHeight = elmHeightInPixel / imageH;\r\n        this.mWidthPadding = wPaddingInPixel / imageW;\r\n        this._initAnimation();\r\n    };\r\n\r\n    setAnimationSpeed(\r\n        tickInterval   // number of update calls before advancing the animation\r\n    ) {\r\n        this.mUpdateInterval = tickInterval;   // how often to advance\r\n    };\r\n\r\n    incAnimationSpeed(\r\n        deltaInterval   // number of update calls before advancing the animation\r\n    ) {\r\n        this.mUpdateInterval += deltaInterval;   // how often to advance\r\n    };\r\n\r\n    setAnimationType(animationType) {\r\n        this.mAnimationType = animationType;\r\n        this.mCurrentAnimAdvance = -1;\r\n        this.mCurrentElm = 0;\r\n        this._initAnimation();\r\n    };\r\n\r\n    updateAnimation() {\r\n        this.mCurrentTick++;\r\n        if (this.mCurrentTick >= this.mUpdateInterval) {\r\n            this.mCurrentTick = 0;\r\n            this.mCurrentElm += this.mCurrentAnimAdvance;\r\n            if ((this.mCurrentElm >= 0) && (this.mCurrentElm < this.mNumElems)) {\r\n                this._setSpriteElement();\r\n            } else {\r\n                this._initAnimation();\r\n            }\r\n        }\r\n    };\r\n\r\n}\r\n\r\nexport { SpriteAnimateRenderable }","import { SpriteAnimateRenderable } from \"./SpriteAnimateRenderable\";\r\n\r\n\r\nclass LightRenderable extends SpriteAnimateRenderable {\r\n    constructor(gEngine, myTexture) {\r\n        super(gEngine, myTexture);\r\n        //Renderable.prototype._setShader.call(this, gEngine.DefaultResources.getLightShader());\r\n        super._setShader(gEngine.DefaultResources.getLightShader());\r\n\r\n        // here is the light source\r\n        this.mLights = [];\r\n    };\r\n\r\n    draw(aCamera) {\r\n        this.mShader.setLights(this.mLights);\r\n        super.draw(aCamera);\r\n    };\r\n\r\n    getLightAt(index) {\r\n        return this.mLights[index];\r\n    };\r\n\r\n    addLight(l) {\r\n        this.mLights.push(l);\r\n    };\r\n}\r\n\r\nexport { LightRenderable };","import { GameObject } from \"../../Engine/GameObjects/GameObject\";\r\nimport { LightRenderable } from \"../../Engine/Renderables/LightRenderable\";\r\n\r\nclass Hero extends GameObject {\r\n\r\n    constructor(gEngine, spriteTexture) {\r\n        super();\r\n        this.gEngine = gEngine;\r\n        this.kDelta = 0.3;\r\n\r\n        this.mDye = new LightRenderable(gEngine, spriteTexture);\r\n        this.mDye.setColor([1, 1, 1, 0]);\r\n        this.mDye.getXform().setPosition(35, 50);\r\n        this.mDye.getXform().setSize(9, 12);\r\n        this.mDye.setElementPixelPositions(0, 120, 0, 180);\r\n        super.setRenderable(this.mDye);\r\n    };\r\n\r\n    update() {\r\n        // control by WASD\r\n        var xform = this.getXform();\r\n        if (this.gEngine.Input.isKeyPressed(this.gEngine.Input.keys.W)) {\r\n            xform.incYPosBy(this.kDelta);\r\n        }\r\n        if (this.gEngine.Input.isKeyPressed(this.gEngine.Input.keys.S)) {\r\n            xform.incYPosBy(-this.kDelta);\r\n        }\r\n        if (this.gEngine.Input.isKeyPressed(this.gEngine.Input.keys.A)) {\r\n            xform.incXPosBy(-this.kDelta);\r\n        }\r\n        if (this.gEngine.Input.isKeyPressed(this.gEngine.Input.keys.D)) {\r\n            xform.incXPosBy(this.kDelta);\r\n        }\r\n    };\r\n}\r\nexport { Hero };","import { GameObject } from \"../../Engine/GameObjects/GameObject\";\r\nimport { SpriteAnimateRenderable } from \"../../Engine/Renderables/SpriteAnimateRenderable\";\r\nimport {LightRenderable} from \"../../Engine/Renderables/LightRenderable\";\r\n\r\nclass Minion extends GameObject {\r\n    constructor(gEngine, spriteTexture, atY) {\r\n        super();\r\n        this.gEngine = gEngine;\r\n        this.kDelta = 0.2;\r\n        this.mMinion = new LightRenderable(gEngine, spriteTexture);\r\n        this.mMinion.setColor([1, 1, 1, 0]);\r\n        this.mMinion.getXform().setPosition(Math.random() * 100, atY);\r\n        this.mMinion.getXform().setSize(12, 9.6);\r\n        this.mMinion.setSpriteSequence(512, 0,      // first element pixel position: top-left 512 is top of image, 0 is left of image\r\n            204, 164,   // widthxheight in pixels\r\n            5,          // number of elements in this sequence\r\n            0);         // horizontal padding in between\r\n        this.mMinion.setAnimationType(SpriteAnimateRenderable.eAnimationType.eAnimateSwing);\r\n        this.mMinion.setAnimationSpeed(15);\r\n        // show each element for mAnimSpeed updates\r\n        super.setRenderable(this.mMinion);\r\n    };\r\n\r\n    update() {\r\n        // remember to update this.mMinion's animation\r\n        this.mMinion.updateAnimation();\r\n\r\n        // move towards the left and wraps\r\n        var xform = this.getXform();\r\n        xform.incXPosBy(-this.kDelta);\r\n\r\n        // if fly off to the left, re-appear at the right\r\n        if (xform.getXPos() < 0) {\r\n            xform.setXPos(100);\r\n            xform.setYPos(65 * Math.random());\r\n        }\r\n    };\r\n}\r\nexport { Minion };","import { vec3, vec4 } from \"../Lib/gl-matrix\";\r\n\r\nclass Light {\r\n    constructor() {\r\n        this.mColor = vec4.fromValues(0.1, 0.1, 0.1, 1);  // light color\r\n        this.mPosition = vec3.fromValues(0, 0, 5); // light position in WC\r\n        this.mNear = 5;  // effective distance in WC\r\n        this.mFar = 10;  // within near is full on, outside far is off\r\n        this.mIntensity = 1;\r\n        this.mIsOn = true;\r\n    };\r\n\r\n    setColor(c) { this.mColor = vec4.clone(c); };\r\n    getColor() { return this.mColor; };\r\n\r\n    set2DPosition(p) { this.mPosition = vec3.fromValues(p[0], p[1], this.mPosition[2]); };\r\n    setXPos(x) { this.mPosition[0] = x; };\r\n    setYPos(y) { this.mPosition[1] = y; };\r\n    setZPos(z) { this.mPosition[2] = z; };\r\n    getPosition() { return this.mPosition; };\r\n\r\n    setNear(r) { this.mNear = r; };\r\n    getNear() { return this.mNear; };\r\n\r\n    setFar(r) { this.mFar = r; };\r\n    getFar() { return this.mFar; };\r\n\r\n    setIntensity(i) { this.mIntensity = i; };\r\n    getIntensity() { return this.mIntensity; };\r\n\r\n    setLightTo(isOn) { this.mIsOn = isOn; };\r\n    isLightOn() { return this.mIsOn; };\r\n}\r\nexport { Light }","/* File: LightSet.js \r\n *\r\n * Support for working with a set of Lights\r\n */\r\n\r\nclass LightSet {\r\n    constructor() {\r\n        this.mSet = [];\r\n    };\r\n\r\n    numLights() { return this.mSet.length; };\r\n\r\n    getLightAt(index) {\r\n        return this.mSet[index];\r\n    };\r\n\r\n    addToSet(light) {\r\n        this.mSet.push(light);\r\n    };\r\n}\r\n\r\nexport { LightSet }","import { Light } from \"../Engine/Lights/Light\";\r\nimport {LightSet} from \"../Engine/Lights/LightSet\";\r\n\r\nexport const MyGameLights = {\r\n    _createALight,\r\n    _initializeLights,\r\n}\r\n\r\nfunction _createALight(pos, color, n, f, intensity) {\r\n    let light = new Light();\r\n    light.setColor(color);\r\n    light.setXPos(pos[0]);\r\n    light.setYPos(pos[1]);\r\n    light.setZPos(pos[2]);\r\n    light.setNear(n);\r\n    light.setFar(f);\r\n    light.setIntensity(intensity);\r\n\r\n    return light;\r\n};\r\n\r\nfunction _initializeLights() {\r\n    this.mGlobalLightSet = new LightSet();\r\n\r\n    var l = this._createALight(\r\n        [21, 58, 5],       // Hero\r\n        [0.2, 0.2, 0.8, 1],  // some color\r\n        20, 50,             // Near and Far\r\n        5.5                // intensity\r\n    );\r\n    this.mGlobalLightSet.addToSet(l);\r\n\r\n    l = this._createALight(\r\n        [24, 24, 8],           // Left minion position\r\n        [0.4, 0.7, 0.4, 1],    // color\r\n        20, 45,                // near and far\r\n        2.8                    // intensity\r\n    );\r\n    this.mGlobalLightSet.addToSet(l);\r\n\r\n    l = this._createALight(\r\n        [66, 23, 10],            // Right minion position\r\n        [0.7, 0.7, 0.7, 1],     // color\r\n        10, 35,                 // near and far\r\n        3                       // intensity\r\n    );\r\n    this.mGlobalLightSet.addToSet(l);\r\n\r\n    l = this._createALight(\r\n        [72, 57, 6],            // Center of camera \r\n        [0.8, 0.6, 0.6, 1],     // color\r\n        15, 40,                 // near and far\r\n        3                       // intensity\r\n    );\r\n    this.mGlobalLightSet.addToSet(l);\r\n};","\r\nexport const MyGameLightControl = {\r\n    _lightControl,\r\n    _selectLight,\r\n    _printVec3,\r\n}\r\n\r\nfunction _lightControl() {\r\n    var delta = 0.2;\r\n    var msg = \"\";\r\n    const gEngine = this.gEngine\r\n    // player select which light to work \r\n    this._selectLight();\r\n\r\n    // manipulate the light\r\n    var lgt = this.mGlobalLightSet.getLightAt(this.mLgtIndex);\r\n    var p = lgt.getPosition();\r\n    if (gEngine.Input.isKeyPressed(gEngine.Input.keys.Left)) {\r\n        lgt.setXPos(p[0] - delta);\r\n    }\r\n    if (gEngine.Input.isKeyPressed(gEngine.Input.keys.Right)) {\r\n        lgt.setXPos(p[0] + delta);\r\n    }\r\n    if (gEngine.Input.isKeyPressed(gEngine.Input.keys.Up)) {\r\n        lgt.setYPos(p[1] + delta);\r\n    }\r\n    if (gEngine.Input.isKeyPressed(gEngine.Input.keys.Down)) {\r\n        lgt.setYPos(p[1] - delta);\r\n    }\r\n    if (gEngine.Input.isKeyPressed(gEngine.Input.keys.Z)) {\r\n        lgt.setZPos(p[2] + delta);\r\n    }\r\n    if (gEngine.Input.isKeyPressed(gEngine.Input.keys.X)) {\r\n        lgt.setZPos(p[2] - delta);\r\n    }\r\n\r\n    // radius\r\n    if (gEngine.Input.isKeyPressed(gEngine.Input.keys.C)) {\r\n        lgt.setNear(lgt.getNear() + delta);\r\n    }\r\n    if (gEngine.Input.isKeyPressed(gEngine.Input.keys.V)) {\r\n        lgt.setNear(lgt.getNear() - delta);\r\n    }\r\n    if (gEngine.Input.isKeyPressed(gEngine.Input.keys.B)) {\r\n        lgt.setFar(lgt.getFar() + delta);\r\n    }\r\n    if (gEngine.Input.isKeyPressed(gEngine.Input.keys.N)) {\r\n        lgt.setFar(lgt.getFar() - delta);\r\n    }\r\n\r\n    // Intensity\r\n    if (gEngine.Input.isKeyPressed(gEngine.Input.keys.K)) {\r\n        lgt.setIntensity(lgt.getIntensity() + delta);\r\n    }\r\n    if (gEngine.Input.isKeyPressed(gEngine.Input.keys.L)) {\r\n        lgt.setIntensity(lgt.getIntensity() - delta);\r\n    }\r\n\r\n    // on/off\r\n    if (gEngine.Input.isKeyClicked(gEngine.Input.keys.H)) {\r\n        lgt.setLightTo(!lgt.isLightOn());\r\n    }\r\n    msg = \"On(\" + lgt.isLightOn() + \") \" +\r\n        this._printVec3(\"P\", p) +\r\n        \"R(\" + lgt.getNear().toPrecision(3) + \"/\" + lgt.getFar().toPrecision(3) + \") \" +\r\n        \"I(\" + lgt.getIntensity().toPrecision(3) + \")\";\r\n    return msg;\r\n};\r\n\r\nfunction _selectLight() {\r\n    const gEngine = this.gEngine;\r\n    // select which light to work with\r\n    if (gEngine.Input.isKeyClicked(gEngine.Input.keys.Zero)) {\r\n        this.mLgtIndex = 0;\r\n    }\r\n    if (gEngine.Input.isKeyClicked(gEngine.Input.keys.One)) {\r\n        this.mLgtIndex = 1;\r\n    }\r\n    if (gEngine.Input.isKeyClicked(gEngine.Input.keys.Two)) {\r\n        this.mLgtIndex = 2;\r\n    }\r\n    if (gEngine.Input.isKeyClicked(gEngine.Input.keys.Three)) {\r\n        this.mLgtIndex = 3;\r\n    }\r\n};\r\n\r\nfunction _printVec3(msg, p) {\r\n    return msg + \"(\" + p[0].toPrecision(2) + \" \" + p[1].toPrecision(2) + \" \" + p[2].toPrecision(2) + \") \";\r\n};","import { Engine } from \"../Engine/Engine\";\r\nimport { Scene } from \"../Engine/Scene\";\r\nimport { Camera } from \"../Engine/Cameras/Camera\";\r\nimport { FontRenderable } from \"../Engine/Renderables/FontRenderable\";\r\nimport { vec2 } from \"../Engine/Lib/gl-matrix\";\r\nimport { TextureObject } from \"./Objects/TextureObject\";\r\nimport { Hero } from \"./Objects/Hero\";\r\nimport { Brain } from \"./Objects/Brain\";\r\nimport { Minion } from \"./Objects/Minion\";\r\nimport { LightRenderable } from \"../Engine/Renderables/LightRenderable\";\r\nimport { GameObject } from \"../Engine/GameObjects/GameObject\"\r\nimport { Light } from \"../Engine/Lights/Light\";\r\nimport { Renderable } from \"../Engine/Renderables/Renderable\";\r\n\r\nimport { MyGameLights } from \"./MyGame_Lights\";\r\nimport { MyGameLightControl } from \"./MyGame_LightControl\";\r\n\r\nimport \"../style.css\"\r\n\r\n\r\nclass MyGame extends Scene {\r\n    constructor(gEngine) {\r\n        super();\r\n\r\n        this.gEngine = gEngine;\r\n        this.kMinionSprite = \"assets/textures/minion_sprite.png\";\r\n        this.kBg = \"assets/bg.png\";\r\n\r\n        // The camera to view the scene\r\n        this.mCamera = null;\r\n        this.mBg = null;\r\n\r\n        this.mMsg = null;\r\n\r\n        // the hero and the support objects\r\n        this.mHero = null;\r\n        this.mLMinion = null;\r\n        this.mRMinion = null;\r\n\r\n        this.mGlobalLightSet = null;\r\n\r\n        this.mBlock1 = null;   // to verify swiitching between shaders is fine\r\n        this.mBlock2 = null;\r\n\r\n        this.mLgtIndex = 0;    // the light to move\r\n\r\n        Object.assign(this, { ...MyGameLights, ...MyGameLightControl });\r\n\r\n    };\r\n\r\n    loadScene() {\r\n\r\n        this.gEngine.Textures.loadTexture(this.kMinionSprite);\r\n        this.gEngine.Textures.loadTexture(this.kBg);\r\n\r\n    };\r\n\r\n    unloadScene() {\r\n\r\n        this.gEngine.Textures.unloadTexture(this.kMinionSprite);\r\n        this.gEngine.Textures.unloadTexture(this.kBg);\r\n\r\n    };\r\n\r\n    initialize() {\r\n        // console.log(\"*************\")\r\n        // console.log( this.gEngine.ResourceMap.isAssetLoaded(this.kBgClip));\r\n\r\n        //this.gEngine.AudioClips.playBackgroundAudio(this.kBgClip);\r\n\r\n        // Step A: set up the cameras\r\n        this.mCamera = new Camera(\r\n            this.gEngine,\r\n            vec2.fromValues(50, 37.5),   // position of the camera\r\n            100,                        // width of camera\r\n            [0, 0, window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio]         // viewport (orgX, orgY, width, height)\r\n        );\r\n\r\n        this.mCamera.setBackgroundColor([0.8, 0.8, 0.8, 1]);\r\n\r\n        // the light\r\n        this._initializeLights();   // defined in MyGame_Lights.js\r\n\r\n        // the Background\r\n        var bgR = new LightRenderable(this.gEngine, this.kBg);\r\n        bgR.setElementPixelPositions(0, 1024, 0, 1024);\r\n        bgR.getXform().setSize(100, 100);\r\n        bgR.getXform().setPosition(50, 35);\r\n        var i;\r\n        for (i = 0; i < 4; i++) {\r\n            bgR.addLight(this.mGlobalLightSet.getLightAt(i));   // all the lights\r\n        }\r\n        this.mBg = new GameObject(bgR);\r\n        this.mBg.setRenderable(bgR);\r\n\r\n        // \r\n        // the objects\r\n        this.mHero = new Hero(this.gEngine, this.kMinionSprite);\r\n        this.mHero.getRenderable().addLight(this.mGlobalLightSet.getLightAt(0));   // hero light\r\n        this.mHero.getRenderable().addLight(this.mGlobalLightSet.getLightAt(3));   // center light\r\n        // Uncomment the following to see how light affects Dye\r\n        //      this.mHero.getRenderable().addLight(this.mGlobalLightSet.getLightAt(1)); \r\n        //      this.mHero.getRenderable().addLight(this.mGlobalLightSet.getLightAt(2)); \r\n\r\n        this.mLMinion = new Minion(this.gEngine, this.kMinionSprite, 17, 15);\r\n        this.mLMinion.getRenderable().addLight(this.mGlobalLightSet.getLightAt(1));   // LMinion light\r\n        this.mLMinion.getRenderable().addLight(this.mGlobalLightSet.getLightAt(3));   // center light\r\n\r\n        this.mRMinion = new Minion(this.gEngine, this.kMinionSprite, 87, 15);\r\n        this.mRMinion.getRenderable().addLight(this.mGlobalLightSet.getLightAt(2));   // RMinion light\r\n        this.mRMinion.getRenderable().addLight(this.mGlobalLightSet.getLightAt(3));   // center light\r\n\r\n        this.mMsg = new FontRenderable(this.gEngine, \"Status Message\");\r\n        this.mMsg.setColor([1, 1, 1, 1]);\r\n        this.mMsg.getXform().setPosition(1, 2);\r\n        this.mMsg.setTextHeight(3);\r\n\r\n        this.mBlock1 = new Renderable(this.gEngine);\r\n        this.mBlock1.setColor([1, 0, 0, 1]);\r\n        this.mBlock1.getXform().setSize(5, 5);\r\n        this.mBlock1.getXform().setPosition(30, 50);\r\n\r\n        this.mBlock2 = new Renderable(this.gEngine);\r\n        this.mBlock2.setColor([0, 1, 0, 1]);\r\n        this.mBlock2.getXform().setSize(5, 5);\r\n        this.mBlock2.getXform().setPosition(70, 50);\r\n    };\r\n\r\n    drawCamera(camera) {\r\n        camera.setupViewProjection();\r\n        // Step B: Now draws each primitive\r\n        this.mBg.draw(camera);\r\n        this.mBlock1.draw(camera);\r\n        this.mLMinion.draw(camera);\r\n        this.mBlock2.draw(camera);\r\n        this.mHero.draw(camera);\r\n        this.mRMinion.draw(camera);\r\n    };\r\n\r\n    draw() {\r\n        //this.gEngine.AudioClips.playBackgroundAudio(this.kBgClip);\r\n        // Step A: clear the canvas\r\n        this.gEngine.Core.clearCanvas([0.9, 0.9, 0.9, 1.0]); // clear to light gray\r\n\r\n        // Step  B: Activate the drawing Camera\r\n\r\n        // this.drawCamera(this.mCamera)\r\n        // this.mMsg.draw(this.mCamera); //会覆盖所以要draw注意位置\r\n        // this.drawCamera(this.mHeroCam);\r\n        // this.drawCamera(this.mPortalCam);\r\n        // this.drawCamera(this.mBrainCam);\r\n        this.drawCamera(this.mCamera);\r\n        this.mMsg.draw(this.mCamera);   // only draw status in the main camera\r\n\r\n\r\n    };\r\n\r\n    update() {\r\n        var msg = \"Selected Light=\" + this.mLgtIndex + \" \";\r\n\r\n        this.mCamera.update();  // to ensure proper interpolated movement effects\r\n\r\n        this.mLMinion.update(); // ensure sprite animation\r\n        this.mRMinion.update();\r\n\r\n        this.mHero.update();  // allow keyboard control to move\r\n\r\n        // control the selected light\r\n        msg += this._lightControl();\r\n\r\n        this.mMsg.setText(msg);\r\n    };\r\n}\r\nconst gEngine = new Engine();\r\nconst width = window.innerWidth * window.devicePixelRatio;\r\nconst height = window.innerHeight * window.devicePixelRatio;\r\ngEngine.Core.initializeEngineCore(\"GLCanvas\", new MyGame(gEngine), width, height);\r\n\r\nexport { MyGame }\r\n","import { Core } from \"./Core/Core\";\r\nimport { VertexBuffer } from \"./Core/VertexBuffer\";\r\nimport { GameLoop } from \"./Core/GameLoop\";\r\nimport { Input } from \"./Core/Input\";\r\nimport { ResourceMap } from \"./Core/Resources/ResourceMap\";\r\nimport {TextFileLoader} from \"./Core/Resources/TextFileLoader\";\r\nimport { Textures } from \"./Core/Resources/Textures\";\r\nimport { AudioClips } from \"./Core/Resources/AudioClips\";\r\nimport { DefaultResources } from \"./Core/Resources/DefaultResources\";\r\nimport {Fonts} from \"./Core/Resources/Fonts\";\r\n\r\nclass Engine {\r\n    constructor() {\r\n        this.Core = new Core(this);\r\n        this.VertexBuffer = new VertexBuffer(this);\r\n        this.GameLoop = new GameLoop(this);\r\n        this.Input = new Input();\r\n        this.ResourceMap = new ResourceMap();\r\n        this.TextFileLoader = new TextFileLoader(this);\r\n        this.DefaultResources = new DefaultResources(this);\r\n        this.AudioClips = new AudioClips(this);\r\n        this.Textures = new Textures(this);\r\n        this.Fonts = new Fonts(this);\r\n    };\r\n}\r\n\r\nexport { Engine }"],"names":["Core","constructor","gEngine","this","mGL","getGL","_initializeWebGL","htmlCanvasID","width","height","canvas","document","getElementById","getContext","alpha","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","enable","BLEND","pixelStorei","UNPACK_FLIP_Y_WEBGL","write","startScene","scene","loadScene","call","GameLoop","start","initializeEngineCore","myGame","VertexBuffer","initialize","Input","AudioClips","initAudioContext","DefaultResources","clearCanvas","color","clearColor","clear","COLOR_BUFFER_BIT","cleanUp","mSquareVertexBuffer","mTextureCoordBuffer","verticesOfSquare","textureCoordinates","gl","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","getGLVertexRef","getGLTexCoordRef","deleteBuffer","kFPS","kMPF","mPreviousTime","Date","now","mLagTime","mIsLoopRunning","mMyGame","_runLoop","window","requestAnimationFrame","currentTime","elapsedTime","update","draw","unloadScene","_startLoop","ResourceMap","setLoadCompleteCallback","stop","kKeys","Left","Up","Right","Down","Space","Zero","One","Two","Three","Four","Five","Six","Seven","Eight","Nine","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","LastKeyCode","kMouseButton","Middle","mKeyPreviousState","mIsKeyPressed","mIsKeyClicked","keys","mouseButton","mCanvas","mButtonPreviousState","mIsButtonPressed","mIsButtonClicked","mMousePosX","mMousePosY","_onKeyDown","event","keyCode","_onKeyUp","_onMouseMove","inside","bBox","getBoundingClientRect","x","Math","round","clientX","left","y","clientY","top","_onMouseDown","button","_onMouseUp","canvasID","i","addEventListener","isKeyPressed","isKeyClicked","isButtonPressed","isButtonClicked","getMousePosX","getMousePosY","MapEntry","rName","mAsset","mRefCount","mNumOutstandingLoads","mLoadCompleteCallback","mResourceMap","isAssetLoaded","asyncLoadRequested","asyncLoadCompleted","loadedAsset","console","log","_checkForAllLoadCompleted","funToCall","funct","retrieveAsset","r","incAssetRefCount","unloadAsset","c","eTextFileType","eXMLFile","eTextFile","TextFileLoader","loadTextFile","fileName","fileType","callbackFunction","req","XMLHttpRequest","onreadystatechange","readyState","status","alert","open","setRequestHeader","onload","fileContent","DOMParser","parseFromString","responseText","send","unloadTextFile","TextureInfo","name","w","h","id","mName","mWidth","mHeight","mGLTexID","mColorArray","Textures","_processLoadedImage","textureName","image","textureID","createTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","generateMipmap","texInfo","naturalWidth","naturalHeight","loadTexture","img","Image","src","unloadTexture","deleteTexture","activateTexture","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","LINEAR_MIPMAP_LINEAR","deactivateTexture","getTextureInfo","getColorArray","fb","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","pixels","Uint8Array","readPixels","deleteFramebuffer","mAudioContext","mBgAudioNode","AudioContext","webkitAudioContext","e","loadAudio","clipName","responseType","decodeAudioData","response","buffer","unloadAudio","playACue","clipInfo","sourceNode","createBufferSource","connect","destination","playBackgroundAudio","stopBackgroundAudio","loop","isBackgroundAudioPlaying","SimpleShader","vertexShaderFilePath","fragmentShaderFilePath","mCompiledShader","mShaderVertexPositionAttribute","mPixelColor","mModelTransform","mViewProjTransform","mGlobalAmbientColor","mGlobalAmbientIntensity","vertexShader","_compileShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getAttribLocation","vertexAttribPointer","FLOAT","getUniformLocation","getShader","activateShader","pixelColor","aCamera","useProgram","uniformMatrix4fv","getVPMatrix","enableVertexAttribArray","uniform4fv","getGlobalAmbientColor","uniform1f","getGlobalAmbientIntensity","loadObjectTransform","modelTransform","_loadAndCompileShader","file","shaderType","shaderSource","compiledShader","createShader","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","filePath","detachShader","mVertexShader","mFragmentShader","deleteShader","TextureShader","gEnigne","vertexShaderPath","fragmentShaderPath","super","mShaderTextureCoordAttribute","SpriteShader","mTexCoordBuffer","initTexCoord","DYNAMIC_DRAW","setTextureCoordinate","texCoord","bufferSubData","LineShader","mPointSizeRef","mPointSize","getGLLineVertexRef","setPointSize","EPSILON","ARRAY_TYPE","Array","out","random","PI","hypot","arguments","length","sqrt","z","a","b","rotateA","cos","sin","ShaderLightAtIndex","shader","index","uniform1i","mIsOnRef","_setShaderReferences","loadToShader","aLight","isLightOn","p","wcPosToPixel","getPosition","ic","wcSizeToPixel","getNear","oc","getFar","getColor","mColorRef","uniform3fv","mPosRef","mNearRef","mFarRef","mIntensityRef","getIntensity","aLightShader","LightShader","ls","mLights","kGLSLuLightArraySize","mShaderLights","push","numLight","switchOffLight","setLights","l","kSimpleVS","kSimpleFS","mConstColorShader","kTextureVS","kTextureFS","mTextureShader","mSpriteShader","kLineFS","mLineShader","kLightFS","mLightShader","kDefaultFont","setGlobalAmbientIntensity","v","setGlobalAmbientColor","getDefaultFont","getConstColorShader","getTextureShader","getSpriteShader","getLineShader","getLightShader","_createShaders","callBackFunction","Fonts","loadFont","unloadFont","CharacterInfo","mTexCoordLeft","mTexCoordRight","mTexCoordBottom","mTexCoordTop","mCharWidth","mCharHeight","mCharWidthOffset","mCharHeightOffset","mXAdvance","mCharAspectRatio","_storeLoadedFont","fontInfoSourceString","fontName","slice","fontInfo","FontImage","textureSourceString","getCharInfo","aChar","returnInfo","commonInfo","evaluate","XPathResult","ANY_TYPE","iterateNext","charHeight","getAttribute","charPath","charInfo","leftPixel","Number","rightPixel","topPixel","bottomPixel","charWidth","Scene","Error","centerPos","mLL","setBounds","containsPoint","minX","maxX","minY","maxY","intersectsBound","otherBound","boundCollideStatus","eboundCollideStatus","eOutside","eCollideLeft","eCollideRight","eCollideBottom","eCollideTop","eInside","ShakePosition","xDelta","yDelta","shakeFrequency","shakeDuration","mXMag","mYMag","mCycles","mOmega","mNumCyclesLeft","shakeDone","getShakeResults","fx","fy","_nextDampedHarmonic","frac","CameraShake","state","mOrgCenter","getCenter","mShakeCenter","mShake","updateShakeState","s","setRefCenter","CameraManipulation","panWith","aXform","zone","collideWCBound","BoundingBox","pos","newC","getWCCenter","getHeight","getWCHeight","getWidth","getWCWidth","mCameraState","setCenter","panTo","cx","cy","setWCCenter","zoomBy","zoom","setWCWidth","zoomTowards","delta","mCameraShake","updateCameraState","panBy","dx","dy","configInterpolation","stiffness","duration","shake","Interpolate","value","cycles","rate","mCurrentValue","mFinalValue","mRate","mCyclesLeft","getValue","setFinalValue","updateInterpolation","_interpolateValue","InterpolateVec2","cycle","t","ax","ay","CameraState","center","kCycles","kRate","mCenter","setWidth","CameraInput","_mouseDCX","mViewport","Camera","eViewport","eOrgX","_mouseDCY","eOrgY","isMouseInViewport","dcX","dcY","eWidth","eHeight","mouseWCX","mouseWCY","CameraXform","fakeZInPixelSpace","mRenderCache","mWCToPixelRatio","mCameraOrgX","mCameraOrgY","PerRenderCache","wcCenter","wcWidth","viewportArray","bound","mViewportBound","mScissorBound","setViewport","mNearPlane","mFarPlane","mViewMatrix","mProjMatrix","mVPMatrix","mBgColor","Object","assign","xPos","yPos","getViewport","setBackgroundColor","newColor","getBackgroundColor","setupViewProjection","viewport","scissor","SCISSOR_TEST","disable","eye","up","x0","x1","x2","y0","y1","y2","z0","z1","z2","len","eyex","eyey","eyez","upx","upy","upz","centerx","centery","centerz","abs","halfWCWidth","halfWCHeight","right","bottom","near","far","lr","bt","nf","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","a30","a31","a32","a33","b0","b1","b2","b3","bbox","clampAtBoundary","Transform","mPosition","mScale","mRotationInRad","getXPos","setXPos","getYPos","setYPos","setPosition","incXPosBy","incYPosBy","incWidthBy","setHeight","incHeightBy","setSize","getSize","incSizeBy","setRotationInRad","rotationInRadians","setRotationInDegree","rotationInDegree","incRotationByDegree","deltaDegree","incRotationByRad","deltaRad","getRotationInRad","getRotationInDegree","getXform","matrix","rad","Renderable","mShader","mColor","mXform","drawArrays","TRIANGLE_STRIP","setColor","_setShader","myTexture","mTexture","mTextureInfo","mTexWidth","mTexHeight","mTexLeftIndex","mTexBottomIndex","setTexture","getTexture","newTexture","pixelTouches","other","wcTouchPos","yIndex","pixelTouch","xIndex","otherIndex","xDir","yDir","otherXDir","otherYDir","_pixelAlphaValue","_indexToWCPosition","_wcPositionToIndex","setColorArray","returnIndex","wcPos","xDisp","yDisp","floor","returnWCPos","j","xDirDisp","yDirDisp","mTexLeft","mTexRight","mTexTop","mTexBottom","_setTexInfo","setElementUVCoordinate","setElementPixelPositions","imageW","imageH","getElementUVCoordinateArray","eLeft","eRight","eTop","eBottom","FontRenderable","aString","mFont","mOneChar","mText","charIndex","xSize","ySize","xOffset","yOffset","widthOfOneChar","heightOfOneChar","charCodeAt","getText","setText","setTextHeight","getFont","setFont","f","getStringWidth","stringWidth","charSize","mRenderComponent","mVisible","mCurrentFrontDir","mSpeed","getBBox","xform","setVisibility","isVisible","setSpeed","getSpeed","incSpeedBy","setCurrentFrontDir","getCurrentFrontDir","rotateObjPointTo","dir","MIN_VALUE","fdir","cosTheta","dir3d","r3d","az","bx","by","bz","acos","getRenderable","setRenderable","renderableObj","otherObj","myRen","otherRen","mySize","otherSize","myR","otherR","d","mFirstElmLeft","mElmTop","mElmWidth","mElmHeight","mWidthPadding","mNumElems","mUpdateInterval","mAnimationType","eAnimationType","eAnimateRight","mCurrentAnimAdvance","mCurrentElm","_initAnimation","mCurrentTick","eAnimateSwing","eAnimateLeft","_setSpriteElement","setSpriteSequence","elmWidthInPixel","elmHeightInPixel","numElements","wPaddingInPixel","setAnimationSpeed","tickInterval","incAnimationSpeed","deltaInterval","setAnimationType","animationType","updateAnimation","LightRenderable","SpriteAnimateRenderable","getLightAt","addLight","Hero","spriteTexture","kDelta","mDye","Minion","atY","mMinion","Light","mNear","mFar","mIntensity","mIsOn","set2DPosition","setZPos","setNear","setFar","setIntensity","setLightTo","isOn","LightSet","mSet","numLights","addToSet","light","MyGameLights","_createALight","n","intensity","_initializeLights","mGlobalLightSet","MyGameLightControl","_lightControl","_selectLight","lgt","mLgtIndex","_printVec3","toPrecision","msg","innerWidth","devicePixelRatio","innerHeight","kMinionSprite","kBg","mCamera","mBg","mMsg","mHero","mLMinion","mRMinion","mBlock1","mBlock2","bgR","drawCamera","camera"],"sourceRoot":""}